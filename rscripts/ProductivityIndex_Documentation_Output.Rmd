---
title: "Productivity Index - Output"
author: "Emily Markowitz"
date: "Feb. 05, 2020"
output: 
  pdf_document:
    toc: true
    toc_depth: 4
    number_sections: true
    df_print: kable
---

```{r setup, include=FALSE, echo = FALSE, message  = FALSE}
# knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=50),tidy=FALSE)
```


```{r, echo = FALSE, include=FALSE, echo = FALSE, message  = FALSE}
options(scipen=10000)

ln<-log #tricky, tricky, Base R! Didn't fool me this time!!!

####COLOR PALLET#####
#mostly for figures
NOAALightBlue<-"#C9E1E6"
NOAADarkBlue<-"#0098A6"
NOAADarkGrey<-"#56575A" #text
NOAABlueScale<-colorRampPalette(colors = c(NOAALightBlue, NOAADarkBlue))

dir.data<-paste0(dirname(getwd()), "/Data/")
```

#Math Theory: General Total Factor Productivity ($TFP$) Equation

The general form of the $TFP$ can be measured as aggregate output ($Y$) divided by real total inputs ($X$). Rates of TFP growth are constructed using the TÃ¶rnqvist index approach. The TFP growth over two time periods is defined as:

$$ln(TFP_t/TFP_{t-1}) = \sum_{i=1}^n((\frac{R_{i,t} + R_{i,t-1}}{2}) * ln(\frac{Y_{i,t}}{Y_{i,t-1}}))) - \sum_{j=1}^m((\frac{W_{j,t} + W_{j,t-1}}{2}) * ln(\frac{X_{j,t}}{X_{j,t-1}})))$$

Such that:
 
 - Output  = $\sum_{i=1}^n((\frac{R_{it} + R_{it-1}}{2}) * ln(\frac{Y_{it}}{Y_{it-1}}))$

 - Input = $\sum_{j=1}^n((\frac{W_{jt} + W_{jt-1}}{2}) * ln(\frac{X_{jt}}{X_{jt-1}}))$

where: 

 - $Y_i$ are individual outputs. This will later be refered to as $Q_i$ in the following equations. 
 
 - $X_j$ are individual inputs
 
 - $R_i$ are output revenue shares
 
 - $W_j$ are input cost shares
 
 - $t$ and $t-1$ are time subscripts, where 1 is the minimum year in the dataset
 
 - $i$ is category, e.g., Finfish (=1), Shellfish (=2)

 - $s$ is species, e.g., Salmon, Alewife, Surf Clams

-------

#Output Method: From Price to Quantity Measures

###Variable Summary

Variables

 - $Q$ are individual quantity outputs in pounds (lbs). 
 
 - $V$ are individual value outputs in dollars ($)

 - $R$ are output revenue shares
 
 - $P$ are prices

 - $PC$ are price changes
 
 - $PI$ are price indicies, often defined by a price from a base year $baseyr$
 
 - $baseyr$ is the year to base all indicides from
 
 
 Inidicies
 
 - $t$ and $t-1$ are time subscripts, where 1 is the minimum year in the dataset
 
 - $i$ is category, e.g., Finfish (=1), Shellfish (=2)

 - $s$ is species, e.g., Salmon, Alewife, Surf Clams
 

###Data requirements

We need time series data for the value of all species ($V_{t}$; e.g., Total), value of all species in a category (i) ($V_{i=1}$; e.g., Finfish), value of each species in a category (i) ($V_{i=1, s=n}$; e.g., Salmon and Summer Flounder), quanity of all species in a category (i) (in lbs, $Q_{i=1}$; e.g., Finfish and others), and the quantity of each species in a category (i) ($Q_{i=1, s=n}$; e.g., Salmon and Flounder):


#### Edit Data

Here we summate the category and total V because there may be instances where these values may not be the sum of their parts (though they are here). The caluclation Price Index aims to deal with this potiental issue. 

```{r, echo = TRUE, warning = FALSE}

temp<-read.csv(file = paste0(dir.data, "Tornqvist Index-Calculations_OutputEx.csv"))
rownames(temp)<-temp$year
temp$year<-NULL

temp.q<-temp[,grepl(pattern = "Q", x = names(temp))]
temp.q$QE0_0Total<-rowSums(temp.q, na.rm = T)
temp.q$QE1_0Finfish<-rowSums(temp.q[,grepl(x = names(temp.q), pattern = "Q1") ], na.rm = T)
temp.q$QE2_0Shellfish<-rowSums(temp.q[,grepl(x = names(temp.q), pattern = "Q2") ], na.rm = T)

temp.v<-temp[,grepl(pattern = "V", x = names(temp))]
temp.v$V0_0Total<-rowSums(temp.v, na.rm = T)
temp.v$V1_0Finfish<-rowSums(temp.v[,grepl(x = names(temp.v), pattern = "V1") ], na.rm = T)
temp.v$V2_0Shellfish<-rowSums(temp.v[,grepl(x = names(temp.v), pattern = "V2") ], na.rm = T)

temp<-orgional.data<-cbind.data.frame(temp.q, temp.v)

```


```{r, echo  = FALSE}
temp %>%
    knitr::kable(row.names = T, booktabs = T)
```


#### The nameing conventions of the column names. 

For example, in "V1_0Finfish":

 - "V"... refers to the variable represented in the column (here V = "Value")
 
 - ..."1"... refers to the category index (here, = Finfish)
 
  - ..."_"... is simply a seperator in the title
 
 - Since this is the total, ..."0".. refers to the index of the species, which is not relevant since this is the sum of the category, hense = 0
 
 - ..."Finfish" is purely descriptive (here the name of the category), so you can follow along with what is happening!
 
 
Similarly for "Q2_2Clam": 

 - "Q"... refers to the variable represented in the column (here Q = "Quantity")
 
 - ..."2"... refers to the category index (here, = Shellfish)
 
 - ..."_"... is simply a seperator in the title
 
 - ..."2".. refers to the index of the species, such that this organism happens to be the second species of this category. 
 
 - ..."Clams" is purely descriptive (here the name of the species), so you can follow along with what is happening!


We can do the structuring work in a function

This funciton standardizes the length of the category or species numbers e.g.,(numbers of 33, 440, and 1 are converted to 033, 440, and 001)

```{r, echo  = FALSE}
# print(numbers0)
```

###Lets get started


In most of the following examples, we will just focus on the finfish (i=1) side of the equation. 

```{r, echo  = TRUE}
ii<-1 #The category index value
warnings.list<-list() #save issues 
baseyr<-2010
```

Here I am just going to do some housekeeping:
```{r, echo  = TRUE}

    #If data are missing by the below percentage, remove data
    PercentMissingThreshold<-0.50


  NumberOfSpecies<-numbers0(x = c(0, strsplit(x = 
                                                strsplit(x = names(temp)[1], 
                                                         split = "_")[[1]][2], 
                                              split = "[a-zA-Z]")[[1]][1]))[1]


    NameBaseTotal<-substr(x = sort(names(temp)[grep(x = names(temp), 
                                                    pattern = "0Total")], decreasing = T)[1],
                        start = 2, stop = nchar(sort(names(temp)[grep(x = names(temp), 
                                                                      pattern = "0Total")], decreasing = T)[1]))
    
    VColumns<-grep(pattern = paste0("V", ii,"_"), 
                 x = substr(x = names(temp), 
                            start = 1, 
                            stop = (2+nchar(ii))))
  
  NameBasecategory<-substr(start = 2, 
                             stop = nchar(names(temp)[VColumns[(grepl(
                               pattern = paste0("V", ii,"_", 
                                                numbers0(x = c(0, length(VColumns)-1))[1]), 
                               x = names(temp)[VColumns]))]]), 
                             x = names(temp)[VColumns[(grepl(
                               pattern = paste0("V", ii,"_", 
                                                numbers0(x = c(0, length(VColumns)-1))[1]), 
                               x = names(temp)[VColumns]))]])  
  
  VColumns<-VColumns[!(grepl(pattern = paste0("V", ii,"_", 
                                              numbers0(x = c(0, length(VColumns)-1))[1]), 
                             x = names(temp)[VColumns]))]
```


###Remove any V and Q data where V column has less data than the specifed $percentmissingthreshold$

```{r, echo = TRUE}

VColumns0<-VColumns
QColumns0<-QColumns<-which(names(temp) %in% 
                             paste0("Q", substr(x = names(temp)[VColumns], 
                                                start = 2, 
                                                stop = nchar(names(temp)[VColumns]))))
for (i in 1:length(VColumns)) {
  
  #if the percent missing is less in V or Q columns for a species than the percentmissingtrheshold, we remove the data before the analysis
  if (sum(is.na(temp[VColumns[i]]))/nrow(temp) > PercentMissingThreshold | #V
      sum(is.na(temp[QColumns[i]]))/nrow(temp) > PercentMissingThreshold ) {#Q
    
    names(temp)[VColumns[i]]<-paste0("REMOVED_", names(temp)[VColumns[i]])
    VColumns0<-VColumns0[!(VColumns0 %in% VColumns[i])]
    names(temp)[QColumns[i]]<-paste0("REMOVED_", names(temp)[QColumns[i]])
    QColumns0<-QColumns0[!(QColumns0 %in% QColumns[i])]
  }
}

VColumns<-names(temp)[VColumns0]
QColumns<-names(temp)[QColumns0]

```


```{r, echo  = FALSE}
temp %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Caluclate Catagory Sums of $V$ and $Q$

Because we removed some columns for not meeting a perecent missing threshold and those columns will not be used at all in any part of the analysis, we need to calculate the totals of $V$ and $Q$ for the catagories and the fishery as a whole. 

```{r, echo = TRUE}
names(temp)[grep(pattern = NameBasecategory, x = names(temp))]<-
  paste0("REMOVED_", 
         names(temp)[grep(pattern = NameBasecategory, x = names(temp))])

  # Q
  temp.q<-temp[,grepl(pattern = paste0("Q", ii), x = substr(names(temp), start = 1, stop = 2)) ]
  temp.q<-data.frame(temp.q)
  if (ncol(temp.q)>1) {
    temp.q<-rowSums(temp.q, na.rm = T)
  }
  temp[ncol(temp)+1]<-temp.q
  names(temp)[ncol(temp)]<-paste0("QE",NameBasecategory)
  
  # V
  temp.v<-temp[,grepl(pattern = paste0("V", ii), x = substr(names(temp), start = 1, stop = 2)) ]
  temp.v<-data.frame(temp.v)
  if (ncol(temp.v)>1) {
    temp.v<-rowSums(temp.v, na.rm = T)
  }
  temp[ncol(temp)+1]<-temp.v
  names(temp)[ncol(temp)]<-paste0("V",NameBasecategory)
```

```{r, echo  = FALSE}
temp0<-temp[,grep(pattern = NameBasecategory, x = names(temp))]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```


###Price for each species ($P_{s,i,t}$; e.g., Salmon and Flounder)
We first measure output price for each species in each of the categories (e.g., Finfish & Others and Shellfish) using detailed landings time series data on value ($) and pounds (lbs). 

Price for a species (s) of category (i) in year (t) = 

$$P_{s,i,t} = V_{s,i,t}/Q_{s,i,t}$$

where: 

 - $P_{s,i,t}$ is the price per individual species (s), category (i), for each year (t)
 
 - $Q_{s,i,t}$ is the quantity (lb) per individual species (s), category (i), for each year (t)
 
 - $V_{i,t}$ is the value ($) per category (i), for each year (t)

Here we calculate the price for each species

```{r, echo  = TRUE}

    # Find which columns in this table are price Columns - we will need this for later
    PColumns<-paste0("P", substr(x = VColumns, 
                                    start = 2, 
                                    stop = nchar(VColumns)))

#####Price for each species#####
tempP<-data.frame(data = rep_len(x = NA, length.out = nrow(temp)))
for (c in 1:length(VColumns)) {
  
    NameBase<-substr(start = 2, 
                   stop = nchar(VColumns[c]), 
                   x = VColumns[c]) 
    
    Q0<-temp[,names(temp) %in% paste0("Q", NameBase)]
    V0<-temp[,names(temp) %in% paste0("V", NameBase)] #to make sure its the same column
  tempP[,c]<-V0/Q0
  names(tempP)[c]<-paste0("P", NameBase ) #name the column
}

  tempP<-as.matrix(tempP)
  tempP[tempP %in% Inf]<-NA
  tempP<-data.frame(tempP)
  temp<-cbind.data.frame(temp, data.frame(tempP))
```

```{r, echo  = FALSE}
tempP %>%
    knitr::kable(row.names = T, booktabs = T)
```


There may be instances where price cannot (or should not) be calculated because there is no or too few Q or V data for that species in a year or ever. The next goal will be to calculate the price change, so we need to have a value in there that won't show change. If we left a 0 in the spot, then the price change from 0 to the next year would be huge and misrepresented on the index. To avoid this, we have to deal with four senarios: 

#### 1. If there are instances for a species where there are too few pairs of $V$ and/or $Q$ are completely missing from the timeseries or where a percent of $V$ is missing from the timeseries, we will remove the offending price columns entierly, so they don't influence the downstream price change or price index calculations.  

Let's say here that if `r PercentMissingThreshold*100 `% of the data is missing in a given $V_{s,i,t}$, don't calculate that species $P_{s,i,t}$

```{r, echo  = TRUE}
#Find which columns in this table are price Columns

cc<-c() #Empty
for (c in 1:length(VColumns)) {
  
  #If price could never be caluclated at any point in the timeseries (is 0/NaN/NA) for a column (c) 
  #Remove the column from the analysis. 
  #We will not be removing the column from the data, but simply remove it from the varaible "PColumns"
  if (#sum(temp[,PColumns[c]] %in% c(0, NA, NaN)) %in% nrow(temp) |
      sum(temp[,PColumns[c]] %in% c(0, NA, NaN))/nrow(temp) > PercentMissingThreshold) {
    cc<-c(cc, c)#Collect offending columns
  }
  
}

if (length(cc)>0){
  PColumns<-PColumns[-cc]
  # VColumns<-VColumns[-cc]
  # QColumns<-QColumns[-cc]
}
  
```

```{r, echo  = FALSE}
temp0<-temp[,PColumns]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

$$where \begin{cases} if: V_{i,t=1} = 0, then: V_{i,t=1} = V_{i,t=1+1...} \\ if: V_{i,t\neq1} = 0, then: V_{i,t} = V_{i,t-1} \end{cases}$$


#### 2. If the first value of P is 0 in a timeseries, we let the next available non-zero value of P in the timeseries inform the past. 

```{r, echo  = TRUE}

for (c in 1:length(PColumns)) {
  
  #If the first value of the timeseries of this column (c) is 0/NaN/NA
  #Change the first value (and subsequent 0/NaN/NA values) to the first available non-0/NaN/NA value
  if (temp[1,PColumns[c]] %in% c(0, NA, NaN)) {
    findfirstvalue<-temp[which(!(temp[,PColumns[c]]  %in% c(0, NA, NaN))), 
                         PColumns[c]][1]
    temp[1,PColumns[c]]<-findfirstvalue
  }
}
```

```{r, echo  = FALSE}
temp0<-temp[,PColumns]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

#### 3. If there is a value in the middle of P's timeseries that is 0, we let the most recent past available non-zero of P in the timeseries inform the future. 

```{r, echo  = TRUE}
#Find which columns in this table are price Columns
for (c in 1:length(PColumns)) {
  
  #If a middle value of the timeseries of this column (c) is 0/NaN/NA
  #Change the currently 0/NaN/NA value to the previous available non-0/NaN/NA value
  if (sum(temp[,PColumns[c]] %in% c(0, NA, NaN))>0) {
    troublenumber<-which(temp[,PColumns[c]] %in% c(0, NA, NaN))
    for (r in 1:length(troublenumber)){
      findlastvalue<-temp[troublenumber[r]-1, PColumns[c]][1]
      temp[troublenumber[r],PColumns[c]]<-findlastvalue
    }
  }
}
```

```{r, echo  = FALSE}
temp0<-temp[,PColumns]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```


###Value of species $VV_{i,t}$ where P was able to be calculated

$R_{i,t}$, defined and discussed in the subsequent step, will need to sum to 1 across all species in a category. Therefore, you will need to sum a new total of $V_{i,t}$ (called $VV_{i,t}$) for the category using only values for species that were used to calculate $P_{i,t}$ (called  $V_{s,i,t, available}$). 

$$VV_{i,t} = \sum_{s=1}^{n}(V_{s,i,t, available})$$

where: 

 - $VV_{i,t}$ is the new total of $V_{i,t}$ (called $VV_{i,t}$) for the category using only values for species that were used to calculate $P_{i,t}$

 - $V_{s,i,t, available}$ are the $V_{s,i,t}$ where P were able to be calculated


```{r, echo  = TRUE}

VVColumns<-paste0("V", substr(x = PColumns, start = 2, stop = nchar(PColumns)))

temp0<-data.frame(temp[,names(temp) %in% VVColumns], 
                  rowSums(temp[,names(temp) %in% VVColumns], na.rm = T))
names(temp0)[ncol(temp0)]<-paste0("VV",NameBasecategory)
temp0<-data.frame(temp0)
temp[ncol(temp)+1]<-temp0[ncol(temp0)]

temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Revenue Share for each species ($R_{s,i,t}$; e.g., Salmon and Flounder) 

$$R_{s,i,t} = V_{s,i,t}/VV_{i,t}$$

where: 

 - $R_{s,i,t}$ is the revenue share per individual species (s), category (i), for each year (t)
 
 - $V_{s,i,t}$ is the value ($) per individual species (s), category (i), for each year (t)


Here we divide $V_{s,i,t}$ by $VV_{i,t}$ because $VV_{i,t}$ only includes species used to calculate $V_{s,i,t}$ as per the above price calculations. 

```{r, echo = TRUE}
tempR<-data.frame(data = rep_len(x = NA, length.out = nrow(temp)))
for (c in 1:length(PColumns)) {
  
  #for renaming the columns
    NameBase<-substr(start = 2, 
                   stop = nchar(PColumns[c]), 
                   x = PColumns[c]) 
    
  V<-(temp[,names(temp) %in% paste0("VV", NameBasecategory)])  # sum of V where P was calculated
  V0<-temp[,names(temp) %in% paste0("V", NameBase)] #V of species; to make sure its the same column
  tempR[,c]<-V0/V
  names(tempR)[c]<-paste0("R", NameBase ) #name the column
}

tempR<-data.frame(tempR)
temp<-cbind.data.frame(temp, tempR)
```


```{r, echo = FALSE}
tempR %>%
    knitr::kable(row.names = T, booktabs = T)
```

As an additional check, let's make sure that each row sums to 1. 
```{r, echo = FALSE}
rowSums(tempR, na.rm = T) %>%
    knitr::kable(row.names = T, booktabs = T)

if (sum(rowSums(tempR, na.rm = T)) != nrow(temp)) {
  warnings.list[length(warnings.list)+1]<-paste0("Rows of R_{s,i,t} for ",NameBasecategory," did not sum to 1")
}
```

###Price Changes for each species ($PC_{s,i,t}$ aka $\Delta ln(P_{s,i,t})$; e.g., Salmon and Flounder)

$$PC_{i,t} = ln(\frac{P_{i,t}}{P_{i,t-1}}) = \sum_{s=1}^n([\frac{R_{s,i,t} + R_{s,i,t-1}}{2}] * [ln(\frac{P_{s,i,t}}{P_{s,i,t-1}}]) = \sum_{s=1}^n([\frac{R_{s,i,t} + R_{s,i,t-1}}{2}] * [ln(P_{s,i,t}) - ln(P_{s,i,t-1})]) $$ 


Such that:

category's (i) Price Change = $ln(\frac{P_{i,t}}{P_{i,t-1}})$

category's (i) Price Change for each species (s) = $\frac{R_{s,i,t} + R_{s,i,t-1}}{2}$

category's (i) Revenue Share for each species (s) = $ln(\frac{P_{s,i,t}}{P_{s,i,t-1}}$

Which can be adapted to this function/macro:

```{r, echo  = TRUE}
#A function to caluclate the price change
# print(PriceChange)
```

Now put it into practice for the total dataset:

```{r, echo  = TRUE}
#Find which columns in this table are price and revenue share columns
tempPC<-data.frame(data = rep_len(x = NA, length.out = nrow(temp)))
for (c in 1:length(PColumns)){
  #For nameing columns
    NameBase<-substr(start = 2,
                     stop = nchar(PColumns[c]),
                     x = PColumns[c])
  
  # Calculate
  P0<-temp[, names(temp) %in% paste0("P", NameBase)]
  R0<-temp[, names(temp) %in% paste0("R", NameBase)] #to make sure its the same column
  tempPC[,c]<-PriceChange(R0, P0)
  names(tempPC)[c]<-paste0("PC", NameBase ) #name the column
}

temp<-cbind.data.frame(temp, tempPC)
temp[ncol(temp)+1]<-rowSums(tempPC, na.rm = T)
names(temp)[ncol(temp)]<-paste0("PC", NameBasecategory)

```

For reference, here are the Price Changes for each species ($PC_{s,i,t}$):

```{r, echo  = FALSE}
rownames(tempPC)<-rownames(temp)

tempPC %>%
    knitr::kable(row.names = T, booktabs = T)
```


And here is the summed ($\sum$) Price Change for the category:

```{r, echo  = FALSE}
temp0<-cbind.data.frame("Other..." = rep_len(x = "...", length.out = nrow(temp)), 
                 temp[,(ncol(temp)-4):ncol(temp)])
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```


###Price Index for the each category ($PI_t$)

We calculate the price index first by comparing by multiplying the previous years $PI_{t-1}$ by that year's price change $PC_{t}$, where the PI of the first year $PI_{t=firstyear} = 1$

$$PI_t = PI_{t-1}*exp(ln(\frac{P_{i,t}}{P_{i,t-1}})) = PI_{t-1}*exp(PC_{t})$$

Where

$$PI_{i, t_{first year}} = 1$$

```{r, echo  = TRUE}
#Note that the first row of this column is = 1
tempPI1<-data.frame(c(1, rep_len(x = NA, length.out = nrow(temp)-1)))
rownames(tempPI1)<-rownames(temp)

PC0<-temp[,names(temp) %in% paste0("PC", NameBasecategory)] #this is equal to ln(P_it/P_it-1)

  # Calculate
for (t in 2:length(tempPI1)){  #Since the first row is defined, we need to start at the second row
    tempPI1[t]<-tempPI1[t-1]*exp(PC0[t])
}
```

Then, to change the price (calulated later) into base year dollars, we use the following equation: 

$$PI_{t} = PI_{t}/PI_{t = baseyear}$$

In this example, we'll decide that the base year is `r baseyr`, for whatever reason. Notice that the $PI_{i,t=baseyr} = 1$ 

```{r, echo  = TRUE}
tempPI2<-tempPI1/tempPI1[rownames(tempPI1) %in% baseyr,]
```

```{r, echo  = FALSE}
temp0<-cbind.data.frame(tempPI1, tempPI2)
names(temp0)<-c("tempPI1", "tempPI2")
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

Which can be summarized in this function: 
```{r, echo  = TRUE}
print(PriceIndex)
```

And we add the $PI$ to the data
```{r, echo  = TRUE}
tempPI<-PriceIndex(temp, BaseColName = NameBasecategory, baseyr)
temp[ncol(temp)+1]<-(tempPI)
names(temp)[ncol(temp)]<-paste0("PI", NameBasecategory)
```

```{r, echo  = FALSE}
temp0<-tempPI
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Implicit Quantity/Output for each category ($Q_{i,t}$; Finfish & others and Shellfish)

Note here that all columns of $V$ are being used, despite having been removed earlier in the analysis when $PI$ could not be calculated and $PI$ columns have functionally been removed from the analysis. 

$$Q_{i,t}=V_{i,t}/PI_{i,t}$$


```{r, echo  = TRUE}
temp[,ncol(temp)+1]<-temp[,names(temp) %in% paste0("V", NameBasecategory)]/
  temp[,names(temp) %in% paste0("PI", NameBasecategory)]

names(temp)[ncol(temp)]<-paste0("Q", NameBasecategory)
```


```{r, echo  = FALSE}
temp0<-cbind.data.frame("Other..." = rep_len(x = "...", length.out = nrow(temp)), 
                 temp[,(ncol(temp)-4):ncol(temp)])
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Analysis Warnings Checks

####1. When back calculated, $V_t$ did not equal $P_t * Q_{t}$

$$V_i = P_t * Q_i$$
  
```{r, echo  = TRUE}
  temp0<-temp[names(temp) %in% c(paste0("Q",NameBasecategory), 
                                 paste0("PI",NameBasecategory), 
                                 paste0("V",NameBasecategory))]
  
  temp0[,(ncol(temp0)+1)]<-temp0[,paste0("Q",NameBasecategory)]*temp0[,paste0("PI",NameBasecategory)]
  names(temp0)[ncol(temp0)]<-paste0("V", NameBasecategory, "_Check")
  
  if (sum(temp0[,paste0("V", NameBasecategory, "_Check")] %in% 
          temp0[,paste0("V", NameBasecategory)]) == nrow(temp0)) {
    warnings.list[length(warnings.list)+1]<-"When back calculated, V_{i,t} did not equal PI_{i,t} * Q_{i,t}"
    print("When back calculated, V_{i,t} did not equal PI_{i,t} * Q_{i,t}")
  }
```


```{r, echo  = FALSE}
temp0%>%
    knitr::kable(row.names = T, booktabs = T)
```

####2. When back calculated, $Q_{t}$ did not equal $V_t / PI_{t}$
  
$$Q_{i,t} = V_t / PI_{i,t}$$
  
```{r, echo  = TRUE}
  temp0[,(ncol(temp0)+1)]<-temp0[,paste0("V",NameBasecategory)]/temp0[,paste0("PI",NameBasecategory)]
  names(temp0)[ncol(temp0)]<-paste0("Q", NameBasecategory, "_Check")
  
  if (sum(temp0[,paste0("Q", NameBasecategory, "_Check")] %in% 
          temp0[,paste0("Q", NameBasecategory)]) == nrow(temp0)) {
    warnings.list[length(warnings.list)+1]<-"When back calculated, Q_{i,t} did not equal V_{i,t}/PI_{i,t}"
    print("When back calculated, Q_{i,t} did not equal V_{i,t}/PI_{i,t}")
  }
```

```{r, echo  = FALSE}
temp0%>%
    knitr::kable(row.names = T, booktabs = T)
```

## Redo Analysis for Shellfish

Pretending that we also did all of that work we just did for FinFish and Others for Shellfish and two species of shellfish, I'll use a function called "species.cat.level" that I will print out for you after this example: 


```{r, echo  = FALSE}
# print(species.cat.level)
```

```{r, echo  = TRUE}
ii<-2 #The category index value

tempS<-species.cat.level(temp, ii, baseyr, maxyr, minyr, 
                         PercentMissingThreshold = PercentMissingThreshold, 
                         warnings.list = warnings.list)
temp<-cbind.data.frame(temp, tempS[[1]])
warnings.list<-tempS[[2]]
###Remove duplicate columns
temp<-temp[, !(grepl(pattern = "\\.[0-9]+", x = names(temp)))]
temp<-temp[, !(grepl(pattern = "\\.[0-9]+", x = names(temp)))]
    
```

What does the Shellfish data look like?
```{r, echo  = FALSE}
temp0<-tempS[[1]][,(ncol(tempS[[1]])-5):ncol(tempS[[1]])]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)

```


###Value for all fisheries for species where P was able to be calculated

$R_{i,t}$, defined and discussed in the subsequent step, will need to sum to 1 across all species in a category. Therefore, you will need to sum a new total of $V_{i,t}$ (called $VV_{t}$) for the category using only values for species that were used to calculate $PI_{i,t}$. 

$$VV_{t} = \sum_{s=1}^{n}(VV_{i,t})$$ 

where: 

 - $VV_{t}$ is the new total of $V_{i,t}$ for the entire fishery using only values for species that were used to calculate $P_{i,t}$

```{r, echo  = FALSE}

temp0<-data.frame(temp[,grep(pattern = "VV", x = names(temp))], 
                  rowSums(temp[,grep(pattern = "VV", x = names(temp))], na.rm = T))
names(temp0)[ncol(temp0)]<-paste0("VV",NameBaseTotal)
temp0<-data.frame(temp0)
temp[ncol(temp)+1]<-temp0[ncol(temp0)]

temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```


###Revenue Share for the entire commercial fishery ($R_t$)

$$R_{i,t} = V_{i,t}/V_{t}$$

where: 

 - $R_{i,t}$ is the revenue share per individual species (s), category (i), for each year (t)
 
 - $V_{i,t}$ is the value ($) per individual species (s), category (i), for each year (t)
 
Here, we don't use $VV_{t}$ beacause we want to expand the proportion to include all of the species caught, regardless if they were used in the price calculations. 

```{r, echo  = TRUE}
names(temp)[names(temp) %in% paste0("V", NameBaseTotal)]<-paste0("REMOVED_V", NameBaseTotal)

temp0<-temp[grep(x = names(temp), 
                            pattern = paste0("V[1-9]+_", NumberOfSpecies))]
temp0<-temp0[,-(grep(x = names(temp0), pattern = c("VV")))]
temp0<-temp0[,-(grep(x = names(temp0), pattern = c("REMOVED_")))]

temp[ncol(temp)+1]<-rowSums(temp0, na.rm = T)
names(temp)[ncol(temp)]<-paste0("V", NameBaseTotal)

#remove duplicates
  temp<-temp[, !(grepl(pattern = "\\.[0-9]+", x = names(temp)))]
  temp <- temp[, !duplicated(colnames(temp))]
  
# temp$R1_0Finfish<-temp$VV1_0Finfish/temp$VV0_0Total
# temp$R2_0Shellfish<-temp$VV2_0Shellfish/temp$VV0_0Total

temp$R1_0Finfish<-temp$V1_0Finfish/temp$V0_0Total
temp$R2_0Shellfish<-temp$V2_0Shellfish/temp$V0_0Total

```

```{r, echo = FALSE}
temp[,c("R1_0Finfish", "R2_0Shellfish", "V1_0Finfish", "V2_0Shellfish", paste0("V", NameBaseTotal))] %>%
    knitr::kable(row.names = T, booktabs = T)
```

As an additional check, let's make sure that each row sums to 1. 
```{r, echo = FALSE}
tempR<-temp[,c("R1_0Finfish", "R2_0Shellfish")]

rowSums(tempR, na.rm = T) %>%
    knitr::kable(row.names = T, booktabs = T)

if (sum(rowSums(tempR, na.rm = T)) != nrow(temp)) {
  warnings.list[length(warnings.list)+1]<-paste0("Rows of R_{i,t} for ",NameBaseTotal," did not sum to 1")
}
```

###Price Changes for the entire commercial fishery ($PC_t$)
Measure output price changes ($PC_t$) for total output ($Q_t$) using $R_{i,t}$ and $P_{i,t}$ estimates. 

$$PC_{t} = ln(\frac{P_{t}}{P_{t-1}}) =  \sum_{i=1}^n([\frac{R_{i,t} + R_{i,t-1}}{2}] * [ln(P_{i,t}) - ln(P_{i,t-1})]) $$

```{r, echo  = TRUE}
temp$PC0_0Total<-rowSums(cbind(PriceChange(R0 = temp$R1_0Finfish, P0 = temp$PI1_0Finfish), 
                            PriceChange(R0 = temp$R2_0Shellfish, P0 = temp$PI2_0Shellfish)), 
                       na.rm = T)
```


```{r, echo  = FALSE}
temp0<-cbind.data.frame("Other..." = rep_len(x = "...", length.out = nrow(temp)), 
                 temp[,(ncol(temp)-4):ncol(temp)])
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Price Index for the entire commercial fishery ($PI_t$)

We calculate the price index first by comparing by multiplying the previous years $PI_{t-1}$ by that year's price change $PC_{t}$, where the PI of the first year $PI_{t=firstyear} = 1$

$$PI_t = PI_{t-1}*exp(ln(\frac{P_{i,t}}{P_{i,t-1}})) = PI_{t-1}*exp(PC_{t})$$

Where

$$PI_{i, t_{first year}} = 1$$

```{r, echo  = TRUE}
tempPI<-PriceIndex(temp, BaseColName = NameBaseTotal, baseyr)
temp[ncol(temp)+1]<-(tempPI)
names(temp)[ncol(temp)]<-paste0("PI", NameBaseTotal)
```

```{r, echo  = FALSE}
temp0<-tempPI
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

### Total Implicit Quantity/Output for the entire commercial fishery ($Q_t = Y_t$)
To get quantity estimates for total output using total value of landings divided by price index as follow: $Y=Q=V/I$ 

$$Q_{t}=V_{t}/PI_{t}$$

```{r, echo  = TRUE}
temp$Q0_0Total<-temp$V0_0Total/temp$PI0_0Total
```

```{r, echo  = FALSE}
temp0<-temp$Q0_0Total
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

### Total Implicit Quantity/Output Index

$$QI_t = Q_t/Q_{t=baseyr}$$

Where:

 - $QI$ is the sum of Q after these equations
 
```{r, echo  = TRUE}
    temp$QI0_0Total<-temp$Q0_0Total/temp$Q0_0Total[rownames(temp) %in% baseyr]
```

```{r, echo  = FALSE}
temp0<-cbind.data.frame("Other..." = rep_len(x = "...", length.out = nrow(temp)), 
                 temp[,(ncol(temp)-4):ncol(temp)])
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

### Sum Total Implicit Quantity Output Index (Optional)

$$QEI_t = QE_t/QE_{t=baseyr}$$

Where:

 - $QE$ is the sum of Q before these equations
 
 - $QEI$ is the index of the sum of Q before these equations

```{r, echo  = TRUE}
temp$QEI0_0Total<-temp$QE0_0Total/temp$QE0_0Total[rownames(temp) %in% baseyr]
```

```{r, echo  = FALSE}
temp0<-cbind.data.frame("Other..." = rep_len(x = "...", length.out = nrow(temp)), 
                 temp[,(ncol(temp)-4):ncol(temp)])
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

### Solve Output portion of the equation for the Output Changes: 

$$QC_{t} = \sum_{i=1}^n((\frac{R_{it} + R_{it-1}}{2}) * ln(\frac{Q_{it}}{Q_{it-1}}))$$

```{r, echo  = TRUE}
temp$QC0_0Total<-rowSums(cbind(PriceChange(R0 = temp$R1_0Finfish, P0 = temp$Q1_0Finfish), 
                            PriceChange(R0 = temp$R2_0Shellfish, P0 = temp$Q2_0Shellfish)), 
                       na.rm = T)
```


```{r, echo  = FALSE}
temp[names(temp) %in% c("Q0_0Total", "QI0_0Total", "QC0_0Total")] %>%
    knitr::kable(row.names = T, booktabs = T)
```

## Analysis Warnings Checks

To make sure our analyses worked as inteded, let's see if we can back calculate our numbers.

We want the calcuated V to equal this check:

####1. When back calculated, $V_t$ did not equal $PI_t * Q_{t}$?


$$V_i = P_t * Q_i$$

```{r, echo  = TRUE}
  temp0<-temp[names(temp) %in% c(paste0("Q",NameBaseTotal), 
                                 paste0("PI",NameBaseTotal), 
                                        paste0("V",NameBaseTotal))]
  
  temp0[,(ncol(temp0)+1)]<-temp0[,paste0("Q",NameBaseTotal)]*temp0[,paste0("PI",NameBaseTotal)]
  names(temp0)[ncol(temp0)]<-paste0("V", NameBaseTotal, "_Check")
  
  if (sum(temp0[,paste0("V", NameBaseTotal, "_Check")] %in% 
          temp0[,paste0("V", NameBaseTotal)]) == nrow(temp0))  {
  warnings.list[length(warnings.list)+1]<-"When back calculated, V_t did not equal PI_t * Q_t"
  print("When back calculated, V_t did not equal PI_t * Q_t")
  }
```

```{r, echo  = FALSE}
temp0%>%
    knitr::kable(row.names = T, booktabs = T)
```

####2. When back calculated, $Q_{t}$ did not equal $V_t / P_{t}$?

$$Q_{i,t} = V_t / P_{i,t}$$


```{r, echo  = TRUE}
  temp0[,(ncol(temp0)+1)]<-temp0[,paste0("V",NameBaseTotal)]/temp0[,paste0("PI",NameBaseTotal)]
  names(temp0)[ncol(temp0)]<-paste0("Q", NameBaseTotal, "_Check")
  
  if (sum(temp0[,paste0("Q", NameBaseTotal, "_Check")] %in% 
          temp0[,paste0("Q", NameBaseTotal)]) == nrow(temp0))  {
  warnings.list[length(warnings.list)+1]<-"When back calculated, Q_t did not equal V_t/PI_t"
  print("When back calculated, Q_t did not equal V_t/PI_t")
  }
```

```{r, echo  = FALSE}
temp0%>%
    knitr::kable(row.names = T, booktabs = T)
```


####3. When back calculated, growth rate?

$$ln(Q_t/Q_{t-1}) = \sum( ( \frac{R_{i, t} - R_{i, t-1}}{2})  * ln(\frac{Q_{i,t}}{Q_{i,t-1}}))$$


```{r, echo  = TRUE}

names0<-c(paste0("Q",NameBaseTotal))
for (i in 1:ii) {
  names0<-c(names0, 
            # names(temp)[grep(pattern = paste0("QE", i, "_", NumberOfSpecies), names(temp))
            #   [!(grep(pattern = paste0("QE", i, "_", NumberOfSpecies), names(temp))) %in% 
            #               grep(pattern = paste0("REMOVED_"), names(temp))] ],
            names(temp)[grep(pattern = paste0("Q", i, "_", NumberOfSpecies), names(temp))],
            names(temp)[grep(pattern = paste0("R", i, "_", NumberOfSpecies), names(temp))])
}

temp0<-temp[,names0]

temp0[,(ncol(temp0)+1)]<-c(NA, ln(temp0[-nrow(temp0),paste0("Q",NameBaseTotal)]/
                              temp0[-1,paste0("Q",NameBaseTotal)]))
names(temp0)[ncol(temp0)]<-"part1"

temp00<-data.frame()
for (i in 1:(ii)) {
  R0<-temp0[,grep(pattern = paste0("R", i), x = names(temp0))]
  Q0<-temp0[,grep(pattern = paste0("Q", i), x = names(temp0))]
  
  for (r in 2:(nrow(temp))){
    temp00[r,i]<-(((R0[r]-R0[r-1])/2) * ln(Q0[r] / Q0[r-1]) )
  }
}

temp0[,(ncol(temp0)+1)]<-rowSums(temp00)
names(temp0)[ncol(temp0)]<-"part2"

  if (sum(temp0[,"part1"] %in% temp0[,"part2"]) != nrow(temp0))  {
  warnings.list[length(warnings.list)+1]<-"When back calculated, ln(Q_t/Q_{t-1}) = did not equal sum( ( frac{R_{i, t} - R_{i, t-1}}{2})  * ln(\frac{Q_{i,t}}{Q_{i,t-1}}))"
  print("When back calculated, ln(Q_t/Q_{t-1}) = did not equal sum( ( \frac{R_{i, t} - R_{i, t-1}}{2})  * ln(frac{Q_{i,t}}{Q_{i,t-1}}))")
  }
```


```{r, echo  = FALSE}
temp0%>%
    knitr::kable(row.names = T, booktabs = T)
```


####4. Missing Data

```{r, echo  = FALSE}

#value
a<-temp
a<-a[,grep(pattern = "V[1-9]+_[1-9]+", x = names(a))]
if(length(grep(pattern = "REMOVED_", x = names(a)) & 
          grep(pattern = "Total", x = names(a), ignore.case = T)) != 0 ){ 
        a<-a[,-c(grep(pattern = "REMOVED_", x = names(a)), grep(pattern = "Total", x = names(a), ignore.case = T))]
}
ncol0<-ncol(a)
aa<-0
for (iii in 1:ncol(a)) {
  aa<-c(aa, ifelse(sum(a[,iii] %in% c(NA, NaN, 0)) == nrow(a), iii, NA))
}
vv<-(aa[!(is.na(aa))])

#quantity
a<-temp
a<-a[,grep(pattern = "Q[1-9]+_[1-9]+", x = names(a))]
if(length(grep(pattern = "REMOVED_", x = names(a)) & 
          grep(pattern = "Total", x = names(a), ignore.case = T)) != 0 ){ 
        a<-a[,-c(grep(pattern = "REMOVED_", x = names(a)), grep(pattern = "Total", x = names(a), ignore.case = T))]
}
ncol0<-ncol(a)
aa<-0
for (iii in 1:ncol(a)) {
  aa<-c(aa, ifelse(sum(a[,iii] %in% c(NA, NaN, 0)) == nrow(a), iii, NA))
}
qq<-(aa[!(is.na(aa))])

#Price
a<-temp
a<-a[,grep(pattern = "P[1-9]+_[1-9]+", x = names(a))]
if(length(grep(pattern = "REMOVED_", x = names(a)) & 
          grep(pattern = "Total", x = names(a), ignore.case = T)) != 0 ){ 
        a<-a[,-c(grep(pattern = "REMOVED_", x = names(a)), grep(pattern = "Total", x = names(a), ignore.case = T))]
}
ncol0<-ncol(a)
aa<-0
for (iii in 1:ncol(a)) {
  aa<-c(aa, ifelse(sum(a[,iii] %in% c(NA, NaN, 0)) == nrow(a), iii, NA))
}
pp<-(aa[!(is.na(aa))])


  warnings.list[length(warnings.list)+1]<-paste0("Out of ", ncol0," columns, ", ifelse(length(vv)==1, 0, length(vv)-1) ," of species V columns are completely empty, ", ifelse(length(qq)==1, 0, length(qq)-1) ," of species Q columns are completely empty, and ", ifelse(length(pp)==1, 0, length(pp)-1) ," of ", ncol0," species P columns are completely empty. ")
  
    print(warnings.list[[length(warnings.list)]])

```

####5. Removed Data

```{r, echo  = FALSE}

#value
a<-temp
a<-a[,grep(pattern = "V[1-9]+_[1-9]+", x = names(a))]
ncol0<-ncol(a)
a<-names(a)[(grep(pattern = "REMOVED_", x = names(a)))]
vv<-length(a)

#quantity
a<-temp
a<-a[,grep(pattern = "Q[1-9]+_[1-9]+", x = names(a))]
a<-names(a)[(grep(pattern = "REMOVED_", x = names(a)))]
qq<-length(a)

#Price
a<-temp
a<-a[,grep(pattern = "PI[1-9]+_[1-9]+", x = names(a))]
a<-names(a)[(grep(pattern = "REMOVED_", x = names(a)))]
pp<-length(a)

  warnings.list[length(warnings.list)+1]<-paste0("Out of ", ncol0," columns, ", vv ," of species V columns were removed, ", qq ," of species Q columns were removed, and ", pp ," of ", ncol0," species P columns were removed. ")

    print(warnings.list[[length(warnings.list)]])
```


```{r, echo  = FALSE}
temp0%>%
    knitr::kable(row.names = T, booktabs = T)
```

### Graph 1: Price Index
In theory, $PI$ should be negative slope after the baseyear and positive after the base year, but because this data was fabricated without thinking of this, we don't see that here. The index value for the base year is =1, however. 

```{r, echo  = TRUE}
# A function I made to plot this pretty in ggplot2
temp <- temp[, !duplicated(colnames(temp))]
plot1line(temp, PI = temp$PI0_0Total,
            NOAALightBlue, NOAADarkBlue, NOAADarkGrey)
```


### Graph 2: Quantity Index Compare
```{r, echo  = TRUE}
temp0<-temp
temp0$Year<-rownames(temp0)

tempA<-data.frame(temp0[,names(temp0) %in% c("Year", "QI0_0Total")])
names(tempA)<-c("Index", "Year")
tempA$group<-"QI_Total"
tempA$col<-NOAALightBlue

tempB<-data.frame(temp0[,names(temp0) %in% c("Year", "QEI0_0Total")])
names(tempB)<-c("Index", "Year")
tempB$group<-"QEI_Total"
tempB$col<-NOAADarkBlue

temp0<-rbind.data.frame(tempA, tempB)
rownames(temp0)<-NULL
temp0$col<-as.factor(temp0$col)

#A function I made to plot this pretty in ggplot2
plot2line(temp0, Year = temp0$Year, Index=temp0$Index, col = temp0$col, group = temp0$group, 
                    NOAALightBlue, NOAADarkBlue, NOAADarkGrey)
```

### Graph 3: Quantity Compare
```{r, echo  = TRUE}
temp0<-temp
temp0$Year<-rownames(temp0)

tempA<-data.frame(temp0[,names(temp0) %in% c("Year", "Q0_0Total")])
names(tempA)<-c("Quantity", "Year")
tempA$group<-"Q_Total"
tempA$col<-NOAALightBlue

tempB<-data.frame(temp0[,names(temp0) %in% c("Year", "QE0_0Total")])
names(tempB)<-c("Quantity", "Year")
tempB$group<-"QE_Total"
tempB$col<-NOAADarkBlue

temp0<-rbind.data.frame(tempA, tempB)
rownames(temp0)<-NULL
temp0$col<-as.factor(temp0$col)

#A function I made to plot this pretty in ggplot2
plot2line(temp0, Year = temp0$Year, Index=temp0$Quantity, col = temp0$col, group = temp0$group, 
                    NOAALightBlue, NOAADarkBlue, NOAADarkGrey)
```

## Do same analysis via a function!

Now that we know the method, we can simplify most of it into a function and do this whole analysis in 4 easy steps: 

 - A. Import and Edit data
 
 - B. Enter base year
 
 - C. Run the function
 
 - D. Obtain the implicit quantity estimates


### Function to calculate the Implicit Quanity Output at Species and category Level
```{r, echo  = TRUE}
# print(species.cat.level)
```

### Function to calculate the Implicit Quanity Output at Fishery Level
```{r, echo = TRUE}
# print(ImplicitQuantityOutput)
```

### A. Import and Edit data
```{r, echo = TRUE, warning = FALSE}
temp<-read.csv(file = paste0(dir.data, "Tornqvist Index-Calculations_OutputEx.csv"))
rownames(temp)<-temp$year
temp$year<-NULL

temp.q<-temp[,grepl(pattern = "Q", x = names(temp))]
temp.q$QE0_0Total<-rowSums(temp.q, na.rm = T)
temp.q$QE1_0Finfish<-rowSums(temp.q[,grepl(x = names(temp.q), pattern = "Q1") ], na.rm = T)
temp.q$QE2_0Shellfish<-rowSums(temp.q[,grepl(x = names(temp.q), pattern = "Q2") ], na.rm = T)

temp.v<-temp[,grepl(pattern = "V", x = names(temp))]
temp.v$V0_0Total<-rowSums(temp.v, na.rm = T)
temp.v$V1_0Finfish<-rowSums(temp.v[,grepl(x = names(temp.v), pattern = "V1") ], na.rm = T)
temp.v$V2_0Shellfish<-rowSums(temp.v[,grepl(x = names(temp.v), pattern = "V2") ], na.rm = T)

temp<-orgional.data<-cbind.data.frame(temp.q, temp.v)

```

 
### B. Enter base year
```{r, echo = TRUE, warning = FALSE}
 baseyr<-baseyr
```
 
### C. Run the function
```{r, echo = TRUE, warning = FALSE}
temp00<-ImplicitQuantityOutput(orgional.data, baseyr, calcQEI = T, PercentMissingThreshold)
temp<-temp00[[1]]
warnings.list0<-temp00[[2]]
figures.list0<-temp00[[3]]
```

### D. Obtain the implicit quantity estimates
```{r, echo = FALSE, warning = FALSE}
write.csv(x = temp, file = paste0(dir.docu, "Example_Output.csv"))

# temp0<-temp[, grepl(pattern = "0Total", x = names(temp))]
  NumberOfSpecies<-numbers0(x = c(0, strsplit(x = 
                                                strsplit(x = names(temp)[1], 
                                                         split = "_")[[1]][2], 
                                              split = "[a-zA-Z]")[[1]][1]))[1]
  
  temp0<-temp[, grepl(pattern = c("_", NumberOfSpecies), x = names(temp)) &
                !grepl(pattern = c("REMOVED"), x = names(temp))]
  names(temp0)<-gsub(pattern = "0", replacement = "", x = names(temp0))

temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

Did all of the analyses work as intended? 
```{r, echo  = TRUE}
print(warnings.list0)
```

### E. Graph

#### Graph 1: Price Index
For comparison, let's recreate those graphs to make sure we are getting the same output:
```{r, echo  = TRUE}
figures.list0$`_PI_Line`
```


#### Graph 2: Quantity Index Compare
For comparison, let's recreate those graphs to make sure we are getting the same output:
```{r, echo  = TRUE}
figures.list0$`_QuantityIndexCompare`
```

#### Graph 3: Quantity Compare
```{r, echo  = TRUE}
figures.list0$`_QuantityCompare`
```

-------

## Practice with real data (For National Data)

### A. Import and Edit data

Load and subset Data
```{r, echo = TRUE}
#Load Data (This data has been edited to include category columns)
landings.data<-read.csv(file = paste0(dir.data, "landings_edited.csv"))
landings.data<-landings.data[landings.data$Year < 2018,] #FUS 2018 hasn't been published yet
landings.data<-landings.data[landings.data$State %in% unique(state.codes$NAME),]
region<-"National"
#We'll categorize by this column I already added to the data
category0 = "category.orig"
```
  
Summary information about the commercial dataset:
```{r, echo  = TRUE}
summary(landings.data[,c("Tsn", "Year", "State", "AFS.Name", "Pounds", "Dollars", "category.orig")])
```  
  
Edit/Restructure Data
```{r, echo = TRUE}
temp00<-EditCommData(dat = landings.data, category0)
temp<-temp00[[1]]
```

### B. Enter base year
```{r, echo = TRUE}
baseyr<-2010
PercentMissingThreshold = 0.60
```

### C. Run the function
```{r, echo = TRUE}
temp00<-ImplicitQuantityOutput(temp, baseyr, calcQEI = T, PercentMissingThreshold)
temp<-temp00[[1]]
warnings.list0<-temp00[[2]]
figures.list0<-temp00[[3]]
```

### D. Obtain the implicit quantity estimates
```{r, echo = FALSE, warning = FALSE}
write.csv(x = temp, file = paste0(dir.docu, "Output_Commercial_", region, ".csv"))

temp0<-temp[, grepl(pattern = "0Total", x = names(temp))]
names(temp0)<-gsub(pattern = "0", replacement = "", x = names(temp0))
temp0$QE_Total<-NULL
temp0$QEI_Total<-NULL
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

Did all of the analyses work as intended? 
```{r, echo  = TRUE}
print(warnings.list0)
```

### E. Graph

#### Graph 1: Price Index
For comparison, let's recreate those graphs to make sure we are getting the same output:
```{r, echo  = TRUE}
figures.list0$`_PI_Line`
```


#### Graph 2: Quantity Index Compare
For comparison, let's recreate those graphs to make sure we are getting the same output:
```{r, echo  = TRUE}
figures.list0$`_QuantityIndexCompare`
```

#### Graph 3: Quantity Compare
```{r, echo  = TRUE}
figures.list0$`_QuantityCompare`
```

