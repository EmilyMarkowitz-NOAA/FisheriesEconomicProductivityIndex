---
title: "Productivity Index - Output"
author: "Emily Markowitz (Emily.Markowitz@noaa.gov) and Sun-Ling Wang"
date: "Feb. 23, 2020"
output: 
  pdf_document:
    toc: true
    toc_depth: 4
    number_sections: true
    df_print: kable
---

```{r setup, include=FALSE, echo = FALSE, message  = FALSE}
# knitr::opts_chunk$set(echo = echoTF(TRUE, code))
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=50),tidy=FALSE)
```

#Math Theory: General Total Factor Productivity ($TFP$) Equation

The general form of the $TFP$ can be measured as aggregate output ($Y$) divided by real total inputs ($X$). Rates of TFP growth are constructed using the TÃ¶rnqvist index approach. The TFP growth over two time periods is defined as:

$$ln(TFP_t/TFP_{t-1}) = \sum_{i=1}^n((\frac{R_{t,i} + R_{t-1,i}}{2}) * ln(\frac{Y_{t,i}}{Y_{t-1,i}}))) - \sum_{j=1}^m((\frac{W_{j,t} + W_{j,t-1}}{2}) * ln(\frac{X_{j,t}}{X_{j,t-1}})))$$

Such that:
 
 - Output  = $\sum_{i=1}^n((\frac{R_{it} + R_{it-1}}{2}) * ln(\frac{Y_{it}}{Y_{it-1}}))$

 - Input = $\sum_{j=1}^n((\frac{W_{jt} + W_{jt-1}}{2}) * ln(\frac{X_{jt}}{X_{jt-1}}))$

where: 

 - $Y_i$ are individual outputs. This will later be refered to as $Q_i$ in the following equations. 
 
 - $X_j$ are individual inputs
 
 - $R_i$ are output revenue shares
 
 - $W_j$ are input cost shares
 
 - $t$ and $t-1$ are time subscripts, where 1 is the minimum year in the dataset
 
 - $i$ is category, e.g., Finfish (=1), Shellfish (=2)

 - $s$ is species, e.g., Salmon, Alewife, Surf Clams

-------

#Output Method: From Price to Quantity Measures

###Variable Summary

Variables

 - $Q$ are individual quantity outputs in pounds (lbs). 
 
 - $V$ are individual value outputs in dollars ($)

 - $R$ are output revenue shares
 
 - $P$ are prices

 - $PC$ are price changes
 
 - $PI$ are price indicies, often defined by a price from a base year $baseyr$
 
 - $baseyr$ is the year to base all indicides from
 
 
 Inidicies
 
 - $t$ and $t-1$ are time subscripts, where 1 is the minimum year in the dataset
 
 - $i$ is category, e.g., Finfish (=1), Shellfish (=2)

 - $s$ is species, e.g., Salmon, Alewife, Surf Clams
 

###Data requirements

We need time series data for the value of all species ($V_{t}$; e.g., Total), value of all species in a category (i) ($V_{i=1}$; e.g., Finfish), value of each species in a category (i) ($V_{i=1, s=n}$; e.g., Salmon and Summer Flounder), quanity of all species in a category (i) (in lbs, $Q_{i=1}$; e.g., Finfish and others), and the quantity of each species in a category (i) ($Q_{i=1, s=n}$; e.g., Salmon and Flounder):


#### Edit Data

Here we summate the category and total V because there may be instances where these values may not be the sum of their parts (though they are here). The caluclation Price Index aims to deal with this potiental issue. 

```{r, echo = echoTF(TRUE, code), warning = FALSE}

temp<-read.csv(file = paste0(dir.data, "Tornqvist Index-Calculations_OutputEx.csv"))
rownames(temp)<-temp$year
temp$year<-NULL

temp.q<-temp[,grepl(pattern = "Q", x = names(temp))]
temp.q$QE0_0Total<-rowSums(temp.q, na.rm = T)
temp.q$QE1_0Finfish<-rowSums(temp.q[,grepl(x = names(temp.q), pattern = "Q1") ], na.rm = T)
temp.q$QE2_0Shellfish<-rowSums(temp.q[,grepl(x = names(temp.q), pattern = "Q2") ], na.rm = T)

temp.v<-temp[,grepl(pattern = "V", x = names(temp))]
temp.v$V0_0Total<-rowSums(temp.v, na.rm = T)
temp.v$V1_0Finfish<-rowSums(temp.v[,grepl(x = names(temp.v), pattern = "V1") ], na.rm = T)
temp.v$V2_0Shellfish<-rowSums(temp.v[,grepl(x = names(temp.v), pattern = "V2") ], na.rm = T)

temp<-orgional.data<-cbind.data.frame(temp.q, temp.v)

```


```{r, echo = echoTF(FALSE, code)}
temp %>%
    knitr::kable(row.names = T, booktabs = T)
```


#### The nameing conventions of the column names. 

For example, in "V1_0Finfish":

 - "V"... refers to the variable represented in the column (here V = "Value")
 
 - ..."1"... refers to the category index (here, = Finfish)
 
  - ..."_"... is simply a seperator in the title
 
 - Since this is the total, ..."0".. refers to the index of the species, which is not relevant since this is the sum of the category, hense = 0
 
 - ..."Finfish" is purely descriptive (here the name of the category), so you can follow along with what is happening!
 
 
Similarly for "Q2_2Clam": 

 - "Q"... refers to the variable represented in the column (here Q = "Quantity")
 
 - ..."2"... refers to the category index (here, = Shellfish)
 
 - ..."_"... is simply a seperator in the title
 
 - ..."2".. refers to the index of the species, such that this organism happens to be the second species of this category. 
 
 - ..."Clams" is purely descriptive (here the name of the species), so you can follow along with what is happening!


We can do the structuring work in a function

This funciton standardizes the length of the category or species numbers e.g.,(numbers of 33, 440, and 1 are converted to 033, 440, and 001)

```{r, echo = echoTF(FALSE, code)}
# print(numbers0)
```

###Lets get started


```{r, echo = echoTF(TRUE, code)}
ii<-1 #The category index value
baseyr<-2010
pctmiss<-0.50 #If data are missing by the below percentage, remove data
```

In most of the following examples, we will just focus on the finfish (*i*=1) side of the equation. Here *baseyr* is set to `r baseyr` and the *pctmiss* (The percent of data in a column that we will allow to be missing for analysis; more on that later) is set to `r pctmiss `%. 

`r ifelse(showresults == TRUE, "Here I am just going to do some housekeeping:", "")` 

```{r, echo = echoTF(TRUE, code)}

place <-  "Test"

warnings.list<-list() #save issues we encounter in the code 

NumberOfSpecies<-numbers0(x = c(0, strsplit(x = 
                                                strsplit(x = names(temp)[1], 
                                                         split = "_")[[1]][2], 
                                              split = "[a-zA-Z]")[[1]][1]))[1]


NameBaseTotal<-substr(x = sort(names(temp)[grep(x = names(temp), 
                                                    pattern = "0Total")], decreasing = T)[1],
                        start = 2, stop = nchar(sort(names(temp)[grep(x = names(temp), 
                                                                      pattern = "0Total")],
                                                     decreasing = T)[1]))
    
VColumns<-grep(pattern = paste0("V", ii,"_"), 
                 x = substr(x = names(temp), 
                            start = 1, 
                            stop = (2+nchar(ii))))
  
NameBasecategory<-substr(start = 2, 
                             stop = nchar(names(temp)[VColumns[(grepl(
                               pattern = paste0("V", ii,"_", 
                                                numbers0(x = c(0, length(VColumns)-1))[1]), 
                               x = names(temp)[VColumns]))]]), 
                             x = names(temp)[VColumns[(grepl(
                               pattern = paste0("V", ii,"_", 
                                                numbers0(x = c(0, length(VColumns)-1))[1]), 
                               x = names(temp)[VColumns]))]])  
  
VColumns<-VColumns[!(grepl(pattern = paste0("V", ii,"_", 
                                              numbers0(x = c(0, length(VColumns)-1))[1]), 
                             x = names(temp)[VColumns]))]
```


###Remove any V and Q data where V column has less data than the specifed $pctmiss$

```{r, echo = echoTF(TRUE, code)}
VColumns0<-VColumns
QColumns0<-QColumns<-which(names(temp) %in% 
                             paste0("Q", substr(x = names(temp)[VColumns], 
                                                start = 2, 
                                                stop = nchar(names(temp)[VColumns]))))
for (i in 1:length(VColumns)) {
  
  #if the percent missing is less in V or Q columns for a species than the percentmissingtrheshold, we remove the data before the analysis
  if (sum(is.na(temp[VColumns[i]]))/nrow(temp) > pctmiss | #V
      sum(is.na(temp[QColumns[i]]))/nrow(temp) > pctmiss ) {#Q
    
    names(temp)[VColumns[i]]<-paste0("REMOVED_", names(temp)[VColumns[i]])
    VColumns0<-VColumns0[!(VColumns0 %in% VColumns[i])]
    names(temp)[QColumns[i]]<-paste0("REMOVED_", names(temp)[QColumns[i]])
    QColumns0<-QColumns0[!(QColumns0 %in% QColumns[i])]
  }
}

VColumns<-names(temp)[VColumns0]
QColumns<-names(temp)[QColumns0]

```


```{r, echo = echoTF(FALSE, code)}
temp[,1:6] %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Caluclate Category Sums of $V$ and $Q$

Because we removed some columns for not meeting a perecent missing threshold of `r pctmiss`% and those columns will not be used at all in any part of the further analysis, we need to re-calculate the totals of $V$ and $Q$ for the catagories and the fishery as a whole. 

```{r, echo = echoTF(TRUE, code)}
names(temp)[grep(pattern = NameBasecategory, x = names(temp))]<-
  paste0("REMOVED_", 
         names(temp)[grep(pattern = NameBasecategory, x = names(temp))])

  # Q
  temp.q<-temp[,grepl(pattern = paste0("Q", ii), x = substr(names(temp), start = 1, stop = 2)) ]
  temp.q<-data.frame(temp.q)
  if (ncol(temp.q)>1) {
    temp.q<-rowSums(temp.q, na.rm = T)
  }
  temp[ncol(temp)+1]<-temp.q
  names(temp)[ncol(temp)]<-paste0("QE",NameBasecategory)
  
  # V
  temp.v<-temp[,grepl(pattern = paste0("V", ii), x = substr(names(temp), start = 1, stop = 2)) ]
  temp.v<-data.frame(temp.v)
  if (ncol(temp.v)>1) {
    temp.v<-rowSums(temp.v, na.rm = T)
  }
  temp[ncol(temp)+1]<-temp.v
  names(temp)[ncol(temp)]<-paste0("V",NameBasecategory)
```

```{r, echo = echoTF(FALSE, code)}
temp0<-temp[,grep(pattern = NameBasecategory, x = names(temp))]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```


###Price for each species ($P_{s,t,i}$; e.g., Salmon and Flounder)
We first measure output price for each species in each of the categories (e.g., Finfish & Others and Shellfish) using detailed landings time series data on value ($) and pounds (lbs). 

Price for a species (s) of category (i) in year (t) = 

$$P_{s,t,i} = V_{s,t,i}/Q_{s,t,i}$$

where: 

 - $P_{s,t,i}$ is the price per individual species (s), category (i), for each year (t)
 
 - $Q_{s,t,i}$ is the quantity (lb) per individual species (s), category (i), for each year (t)
 
 - $V_{t,i}$ is the value ($) per category (i), for each year (t)

Here we calculate the price for each species

```{r, echo = echoTF(TRUE, code)}

    # Find which columns in this table are price Columns - we will need this for later
    PColumns<-paste0("P", substr(x = VColumns, 
                                    start = 2, 
                                    stop = nchar(VColumns)))

#####Price for each species#####
tempP<-data.frame(data = rep_len(x = NA, length.out = nrow(temp)))
for (c in 1:length(VColumns)) {
  
    NameBase<-substr(start = 2, 
                   stop = nchar(VColumns[c]), 
                   x = VColumns[c]) 
    
    Q0<-temp[,names(temp) %in% paste0("Q", NameBase)]
    V0<-temp[,names(temp) %in% paste0("V", NameBase)] #to make sure its the same column
  tempP[,c]<-V0/Q0
  names(tempP)[c]<-paste0("P", NameBase ) #name the column
}

  tempP<-as.matrix(tempP)
  tempP[tempP %in% Inf]<-NA
  tempP<-data.frame(tempP)
  temp<-cbind.data.frame(temp, data.frame(tempP))
```

```{r, echo = echoTF(FALSE, code)}
tempP %>%
    knitr::kable(row.names = T, booktabs = T)
```


There may be instances where price cannot (or should not) be calculated because there is no or too few Q or V data for that species in a year or ever. The next goal will be to calculate the price change, so we need to have a value in there that won't show change. If we left a 0 in the spot, then the price change from 0 to the next year would be huge and misrepresented on the index. To avoid this, we have to deal with four senarios: 

#### 1. If there are instances for a species where there are too few pairs of $V$ and/or $Q$ are completely missing from the timeseries or where a percent of $V$ is missing from the timeseries, we will remove the offending price columns entierly, so they don't influence the downstream price change or price index calculations.  

Let's say here that if `r pctmiss*100 `% of the data is missing in a given $V_{s,t,i}$, don't calculate that species $P_{s,t,i}$

```{r, echo = echoTF(TRUE, code)}
#Find which columns in this table are price Columns

cc<-c() #Empty
for (c in 1:length(VColumns)) {
  
  #If price could never be caluclated at any point in the timeseries (is 0/NaN/NA) for a column (c) 
  #Remove the column from the analysis. 
  #We will not be removing the column from the data, but simply remove it from the varaible "PColumns"
  if (#sum(temp[,PColumns[c]] %in% c(0, NA, NaN)) %in% nrow(temp) |
      sum(temp[,PColumns[c]] %in% c(0, NA, NaN))/nrow(temp) > pctmiss) {
    cc<-c(cc, c)#Collect offending columns
  }
  
}

if (length(cc)>0){
  PColumns<-PColumns[-cc]
  # VColumns<-VColumns[-cc]
  # QColumns<-QColumns[-cc]
}
  
```

```{r, echo = echoTF(FALSE, code)}
temp0<-temp[,PColumns]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```



#### 2. If the first value of $P_{t,i,s}$ is 0/NA in a timeseries, we (impute) let the next available non-zero/non-NA value of P in the timeseries inform the past. 

$$where \begin{cases} if: P_{t,i=1} = 0, then: P_{t,i=1} = P_{t,i=1+1...} \\ if: P_{t,i\neq1} = 0, then: P_{t,i} = P_{t-1,i} \end{cases}$$

`r ifelse(showresults == TRUE, "We use this *ReplaceFirst* function:", "")` 
```{r, echo = echoTF(TRUE, code), include = includeTF(TRUE, showresults)}
print(ReplaceFirst)
```

```{r, echo = echoTF(TRUE, code)}
temp<-ReplaceFirst(colnames = PColumns, temp) 
```

```{r, echo = echoTF(FALSE, code)}
temp0<-temp[,PColumns]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

#### 3. If there is a value in the middle of $P_{t,i,s}$'s timeseries that is 0/NA, we (impute) let the most recent past available non-zero/non-NA of $P_{t,i,s}$ in the timeseries inform the future. 

`r ifelse(showresults == TRUE, "We use this *ReplaceMid* function:", "")` 
```{r, echo = echoTF(TRUE, code), include = includeTF(TRUE, showresults)}
print(ReplaceMid) 
```

```{r, echo = echoTF(TRUE, code)}
temp<-ReplaceMid(colnames = PColumns, temp) 
```

```{r, echo = echoTF(FALSE, code)}
temp0<-temp[,PColumns]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Impute values of $V_{t,i,s}$ where P was able to be calculated

To ensure that the price index does not rise or fall to quickly with changes (that are really because of NA values) we fill in the missing instances of $V_{t,i,s}$. 

$$where \begin{cases} if: V_{t,i=1} = 0, then: V_{t,i=1} = V_{t,i=1+1...} \\ if: V_{t,i\neq1} = 0, then: V_{t,i} = V_{t-1,i} \end{cases}$$ 


#### 1. If the first value of $V_{t,i,s}$ is 0/NA in a timeseries, we let the next available non-zero value of $V_{t,i,s}$ in the timeseries inform the past. 

```{r, echo = echoTF(TRUE, code)}
VVColumns<-paste0("V", substr(x = PColumns, start = 2, stop = nchar(PColumns)))
temp<-ReplaceFirst(colnames = VVColumns, temp) 
```

```{r, echo = echoTF(FALSE, code)}
temp0<-temp[,VVColumns]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

#### 2. If there is a value in the middle of $V_{t,i,s}$'s timeseries that is 0/NA, we let the most recent past available non-zero of $V_{t,i,s}$ in the timeseries inform the future. 

```{r, echo = echoTF(TRUE, code)}
temp<-ReplaceMid(colnames = VVColumns, temp) 
```

```{r, echo = echoTF(FALSE, code)}
temp0<-temp[,VVColumns]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Value of species $VV_{t,i}$ where P was able to be calculated

$R_{t,i}$, as defined and discussed in the subsequent step, will need to sum to 1 across all species in a category. Therefore, you will need to sum a new total of $V_{t,i}$ available (called $VV_{t,i}$) for the category using only values for species that were used to calculate $P_{t,i}$ (called  $V_{s,t,i, available}$). 

$$VV_{t,i} = \sum_{s=1}^{n}(V_{s,t,i, available})$$

where: 

 - $VV_{t,i}$ is the new total of $V_{t,i}$ (called $VV_{t,i}$) for the category using only values for species that were used to calculate $P_{t,i}$

 - $V_{s,t,i, available}$ are the $V_{s,t,i}$ where P were able to be calculated


```{r, echo = echoTF(TRUE, code)}

temp0<-data.frame(temp[,names(temp) %in% VVColumns], 
                  rowSums(temp[,names(temp) %in% VVColumns], na.rm = T))
names(temp0)[ncol(temp0)]<-paste0("VV",NameBasecategory)
temp0<-data.frame(temp0)
temp[ncol(temp)+1]<-temp0[ncol(temp0)]

temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Revenue Share for each species ($R_{s,t,i}$; e.g., Salmon and Flounder) 

$$R_{s,t,i} = V_{s,t,i}/VV_{t,i}$$

where: 

 - $R_{s,t,i}$ is the revenue share per individual species (s), category (i), for each year (t)
 
 - $V_{s,t,i}$ is the value ($) per individual species (s), category (i), for each year (t)


Here we divide $V_{s,t,i}$ by $VV_{t,i}$ because $VV_{t,i}$ only includes species used to calculate $V_{s,t,i}$ as per the above price calculations. 

```{r, echo = echoTF(TRUE, code)}
tempR<-data.frame(data = rep_len(x = NA, length.out = nrow(temp)))
for (c in 1:length(PColumns)) {
  
  #for renaming the columns
    NameBase<-substr(start = 2, 
                   stop = nchar(PColumns[c]), 
                   x = PColumns[c]) 
    
  V<-(temp[,names(temp) %in% paste0("VV", NameBasecategory)])  # sum of V where P was calculated
  V0<-temp[,names(temp) %in% paste0("V", NameBase)] #V of species; to make sure its the same column
  tempR[,c]<-V0/V
  names(tempR)[c]<-paste0("R", NameBase ) #name the column
}

tempR<-data.frame(tempR)
temp<-cbind.data.frame(temp, tempR)
```


```{r, echo = echoTF(FALSE, code)}
tempR %>%
    knitr::kable(row.names = T, booktabs = T)
```

####Analysis Warnings Checks

As an additional check, let's make sure that each row sums to 1. 
```{r, echo = echoTF(FALSE, code)}
rowSums(tempR, na.rm = T) %>%
    knitr::kable(row.names = T, booktabs = T)
```

Is there a warning?

```{r, echo = echoTF(FALSE, code)}
if (sum(rowSums(tempR, na.rm = T)) != nrow(temp)) {
  warnings.list[length(warnings.list)+1]<-paste0("Rows of R_{s,t,i} for ",NameBasecategory," did not sum to 1")
    a<-warnings.list[length(warnings.list)][[1]]
} else {
    a<-"No warning."
}
```

*`r a `*

###Revenue Share-Weighted Price Changes for each species ($PCW_{s,t,i}$; e.g., Salmon and Flounder)

$$PCW_{t,i,s} = \frac{R_{s,t,i} + R_{s,t-1,i}}{2} * ln(\frac{P_{s,t,i}}{P_{s,t-1,i}}) = \frac{R_{s,t,i} + R_{s,t-1,i}}{2} * [ln(P_{s,t,i}) - ln(P_{s,t-1,i})] $$

Where: 

 - $PCW_{t,i,s}$ = Revenue share-weighted price change for a species (s)


Such that: 

 - category's (i) Price Change for each species (s) = $\frac{R_{s,t,i} + R_{s,t-1,i}}{2}$

 - category's (i) Revenue Share for each species (s) = $ln(\frac{P_{s,t,i}}{P_{s,t-1,i}} = [ln(P_{s,t,i}) - ln(P_{s,t-1,i})]$


`r ifelse(showresults == TRUE, "We use this *PriceChange* function:", "")` 

```{r, echo = echoTF(TRUE, code), include = includeTF(TRUE, showresults)}
print(PriceChange)
```

```{r, echo = echoTF(TRUE, code)}
#Find which columns in this table are price and revenue share columns
tempPC<-data.frame(data = rep_len(x = NA, length.out = nrow(temp)))
for (c in 1:length(PColumns)){
  #For nameing columns
    NameBase<-substr(start = 2,
                     stop = nchar(PColumns[c]),
                     x = PColumns[c])
  
  # Calculate
  P0<-temp[, names(temp) %in% paste0("P", NameBase)]
  R0<-temp[, names(temp) %in% paste0("R", NameBase)] #to make sure its the same column
  tempPC[,c]<-PriceChange(R0, P0)
  names(tempPC)[c]<-paste0("PCW", NameBase ) #name the column
}

temp<-cbind.data.frame(temp, tempPC)
```

###Price Changes for the category ($PC_{t,i}$; e.g., Finfish)

$$PC_{t,i} = ln(\frac{P_{t,i}}{P_{t-1,i}}) = \sum_{s=1}^n(PCW_{t,i,s}) $$ 

Where: 

 - $PC_{t,i}$ = Price change for a category (i)

```{r, echo = echoTF(TRUE, code)}
temp[ncol(temp)+1]<-rowSums(tempPC, na.rm = T)
names(temp)[ncol(temp)]<-paste0("PC", NameBasecategory)
```

```{r, echo = echoTF(FALSE, code)}
temp0<-cbind.data.frame(tempPC, rowSums(tempPC, na.rm = T))
names(temp0)[ncol(temp0)]<-paste0("PC", NameBasecategory)
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```


###Price Index for the each category ($PI_t$)

We calculate the price index first by comparing by multiplying the previous years $PI_{t-1}$ by that year's price change $PC_{t}$, where the PI of the first year $PI_{t=firstyear} = 1$

$$PI_t = PI_{t-1}*\exp(ln(\frac{P_{t,i}}{P_{t-1,i}})) = PI_{t-1}*\exp(PC_{t})$$

Where

$$PI_{i, t_{first year}} = 1$$

```{r, echo = echoTF(TRUE, code)}
#Note that the first row of this column is = 1
tempPI_yr1<-data.frame(c(1, rep_len(x = NA, length.out = nrow(temp)-1)))
rownames(tempPI_yr1)<-rownames(temp)

PC0<-temp[,names(temp) %in% paste0("PC", NameBasecategory)] #this is equal to ln(P_it/P_it-1)

  # Calculate
for (t in 2:nrow(tempPI_yr1)){  #Since the first row is defined, we need to start at the second row
    tempPI_yr1[t,1]<-tempPI_yr1[t-1,1]*exp(PC0[t])
}
```

Then, to change the price index into base year dollars, we use the following equation: 

$$PI_{t} = PI_{t}/PI_{t = baseyear}$$

In this example, our base year is `r baseyr`. Notice that the $PI_{t,i=baseyr} = 1$ 

```{r, echo = echoTF(TRUE, code)}
tempPI_yrb<-tempPI_yr1[,1]/tempPI_yr1[rownames(tempPI_yr1) %in% baseyr,1]
```


`r ifelse(showresults == TRUE, "In the future, we will use this *PriceIndex* function to do this step:", "")` 

```{r, echo = echoTF(TRUE, code), include = includeTF(TRUE, showresults)}
print(PriceIndex)
```

And we add the $PI$ to the data
```{r, echo = echoTF(TRUE, code)}
tempPI<-PriceIndex(temp, BaseColName = NameBasecategory, baseyr)
temp[ncol(temp)+1]<-(tempPI)
names(temp)[ncol(temp)]<-paste0("PI", NameBasecategory)
```

```{r, echo = echoTF(FALSE, code)}
temp0<-cbind.data.frame(tempPI_yr1, tempPI_yrb, tempPI)
names(temp0)<-c("tempPI_yr1", "tempPI_yrb", names(tempPI))
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Implicit Quantity/Output for each category ($Q_{t,i}$; Finfish & others and Shellfish)

Note here that all columns of $V$ are being used, despite having been removed earlier in the analysis when $PI$ could not be calculated and $PI$ columns have functionally been removed from the analysis. 

$$Q_{t,i}=V_{t,i}/PI_{t,i}$$


```{r, echo = echoTF(TRUE, code)}
temp[,ncol(temp)+1]<-temp[,names(temp) %in% paste0("V", NameBasecategory)]/
  temp[,names(temp) %in% paste0("PI", NameBasecategory)]

names(temp)[ncol(temp)]<-paste0("Q", NameBasecategory)
```


```{r, echo = echoTF(FALSE, code)}
temp0<-temp[,ncol(temp)]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Analysis Warnings Checks

####1. When back calculated, $V_t$ should equal $PI_t * Q_{t}$

$$V_{t,i} = PI_{t,i} * Q_{t,i}$$
  
```{r, echo = echoTF(TRUE, code)}
  temp0<-temp[names(temp) %in% c(paste0("Q",NameBasecategory), 
                                 paste0("PI",NameBasecategory), 
                                 paste0("V",NameBasecategory))]
  
  temp0[,(ncol(temp0)+1)]<-temp0[,paste0("Q",NameBasecategory)]*
    temp0[,paste0("PI",NameBasecategory)]
  names(temp0)[ncol(temp0)]<-paste0("V", NameBasecategory, "_Check")
  
```


```{r, echo = echoTF(FALSE, code)}
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

Is there a warning?
```{r, echo = echoTF(FALSE, code)}
  if (length(setdiff(as.character(temp0[,paste0("V", NameBasecategory, "_Check")]), 
                     as.character(temp0[,paste0("V", NameBasecategory)]))) != 0) {
    warnings.list[length(warnings.list)+1]<-"Warning: When back calculated, V_{t,i} did not equal PI_{t,i} * Q_{t,i}"
    
    a<-warnings.list[length(warnings.list)][[1]]
} else {
    a<-"No warning."
}
```

*`r a `*


####2. When back calculated, $Q_{t,i}$ should equal $V_{t,i} / PI_{t,i}$
  
$$Q_{t,i} = V_{t,i} / PI_{t,i}$$
  
```{r, echo = echoTF(TRUE, code)}
  temp0[,(ncol(temp0)+1)]<-temp0[,paste0("V",NameBasecategory)]/temp0[,paste0("PI",NameBasecategory)]
  names(temp0)[ncol(temp0)]<-paste0("Q", NameBasecategory, "_Check")
  
```

```{r, echo = echoTF(FALSE, code)}
temp0%>%
    knitr::kable(row.names = T, booktabs = T)
```

Is there a warning?

```{r, echo = echoTF(FALSE, code)}
  if (length(setdiff(as.character(temp0[,paste0("Q", NameBasecategory, "_Check")]), 
                     as.character(temp0[,paste0("Q", NameBasecategory)]))) != 0) {
    warnings.list[length(warnings.list)+1]<-"Warning: When back calculated, Q_{t,i} did not equal V_{t,i}/PI_{t,i}"
    a<-warnings.list[length(warnings.list)][[1]]
} else {
    a<-"No warning."
}
```

*`r a `*


## Redo Analysis for Shellfish

Now lets redo that whole analysis up to this point (via function) for the two species of the shellfish group, as we will need them for the next steps of this analysis. 

`r ifelse(showresults == TRUE, "We use this *ImplicitQuantityOutput* function to calculate the Implicit Quanity Output at Species and category Level:", "")` 

```{r, echo = echoTF(TRUE, code), include = includeTF(TRUE, showresults)}
print(ImplicitQuantityOutput.species.cat)
```


```{r, echo = echoTF(TRUE, code)}
ii<-2 #The category index value

tempS<-ImplicitQuantityOutput.species.cat(temp, ii, baseyr, maxyr, minyr, 
                         pctmiss = pctmiss, 
                         warnings.list = warnings.list)
temp<-cbind.data.frame(temp, tempS[[1]])
warnings.list<-tempS[[2]]
###Remove duplicate columns
temp<-temp[, !(grepl(pattern = "\\.[0-9]+", x = names(temp)))]
temp<-temp[, !(grepl(pattern = "\\.[0-9]+", x = names(temp)))]
    
```

What does the Shellfish data look like?
```{r, echo = echoTF(FALSE, code)}
temp0<-tempS[[1]][,(ncol(tempS[[1]])-5):ncol(tempS[[1]])]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)

```


###Value for all fisheries for species where P was able to be calculated

$R_{t,i}$, defined and discussed in the subsequent step, will need to sum to 1 across all species in a category. Therefore, you will need to sum a new total of $V_{t,i}$ (called $VV_{t}$) for the category using only values for species that were used to calculate $PI_{t,i}$. 

$$VV_{t} = \sum_{s=1}^{n}(VV_{t,i})$$ 

where: 

 - $VV_{t}$ is the new total of $V_{t,i}$ for the entire fishery using only values for species that were used to calculate $P_{t,i}$

```{r, echo = echoTF(FALSE, code)}

temp0<-data.frame(temp[,grep(pattern = "VV", x = names(temp))], 
                  rowSums(temp[,grep(pattern = "VV", x = names(temp))], na.rm = T))
names(temp0)[ncol(temp0)]<-paste0("VV",NameBaseTotal)
temp0<-data.frame(temp0)
temp[ncol(temp)+1]<-temp0[ncol(temp0)]

temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```


###Revenue Share for the each category ($R_{t,i}$)

$$R_{t,i} = V_{t,i}/V_{t}$$

where: 

 - $R_{t,i}$ is the revenue share per individual species (s), category (i), for each year (t)
 
 - $V_{t,i}$ is the value ($) per individual species (s), category (i), for each year (t)
 
Here, we don't use $VV_{t}$ beacause we want to expand the proportion to include all of the species caught, regardless if they were used in the price calculations. 

```{r, echo = echoTF(TRUE, code)}
names(temp)[names(temp) %in% paste0("V", NameBaseTotal)]<-paste0("REMOVED_V", NameBaseTotal)

temp0<-temp[grep(x = names(temp), 
                            pattern = paste0("V[1-9]+_", NumberOfSpecies))]
temp0<-temp0[,-(grep(x = names(temp0), pattern = c("VV")))]
temp0<-temp0[,-(grep(x = names(temp0), pattern = c("REMOVED_")))]

temp[ncol(temp)+1]<-rowSums(temp0, na.rm = T)
names(temp)[ncol(temp)]<-paste0("V", NameBaseTotal)

#remove duplicates
  temp<-temp[, !(grepl(pattern = "\\.[0-9]+", x = names(temp)))]
  temp <- temp[, !duplicated(colnames(temp))]
  
# temp$R1_0Finfish<-temp$VV1_0Finfish/temp$VV0_0Total
# temp$R2_0Shellfish<-temp$VV2_0Shellfish/temp$VV0_0Total

temp$R1_0Finfish<-temp$V1_0Finfish/temp$V0_0Total
temp$R2_0Shellfish<-temp$V2_0Shellfish/temp$V0_0Total

```

```{r, echo = echoTF(FALSE, code)}
temp[,c("R1_0Finfish", "R2_0Shellfish", "V1_0Finfish", "V2_0Shellfish", paste0("V", NameBaseTotal))] %>%
    knitr::kable(row.names = T, booktabs = T)
```

####Analysis Warnings Checks

As an additional check, let's make sure that each row sums to 1. 

```{r, echo = echoTF(FALSE, code)}
tempR<-temp[,c("R1_0Finfish", "R2_0Shellfish")]

rowSums(tempR, na.rm = T) %>%
    knitr::kable(row.names = T, booktabs = T)
```

Is there a warning?
```{r, echo = echoTF(FALSE, code)}
if (sum(rowSums(tempR, na.rm = T)) != nrow(temp)) {
  warnings.list[length(warnings.list)+1]<-paste0("Warning: Rows of R_{t,i} for ",NameBaseTotal," did not sum to 1")
    a<-warnings.list[length(warnings.list)][[1]]
} else {
  a<-"No warning."
}
```

*`r a `*


###Revenue Share-Weighted Price Changes for each category ($PCW_{t,i}$; e.g., Salmon and Flounder)

$$PCW_{t,i} = \frac{R_{t,i} + R_{t-1,i}}{2} * ln(\frac{PI_{t,i}}{PI_{t-1,i}}) = \frac{R_{t,i} + R_{t-1,i}}{2} * [ln(PI_{t,i}) - ln(PI_{t-1,i})] $$

Where: 

 - $PCW_{t,i}$ = Revenue share-weighted price change for a category (i)

Such that: 

 - Price Change for each category (i) = $\frac{R_{t,i} + R_{t-1,i}}{2}$

 - Revenue Share for each category (i) = $ln(\frac{PI_{t,i}}{PI_{t-1,i}} = [ln(PI_{t,i}) - ln(PI_{t-1,i})]$


```{r, echo = echoTF(TRUE, code)}
#Find which columns in this table are price and revenue share columns
tempPCW<-cbind.data.frame("PCW1_0Finfish" = 
                            PriceChange(R0 = temp$R1_0Finfish, P0 = temp$PI1_0Finfish), 
                          "PCW1_0Shellfish" = 
                            PriceChange(R0 = temp$R2_0Shellfish, P0 = temp$PI2_0Shellfish))
```

###Price Changes for the entire fishery ($PC_{t,i}$; e.g., Finfish)

$$PC_{t} = ln(\frac{P_{t}}{P_{t-1}}) = \sum_{s=1}^n(PCW_{t,i}) $$ 

Where: 

 - $PC_{t}$ = Price change for the entire fishery

```{r, echo = echoTF(TRUE, code)}
temp$PC0_0Total<-rowSums(tempPCW, na.rm=T)
```

```{r, echo = echoTF(FALSE, code)}
temp0<-cbind.data.frame(tempPCW, rowSums(tempPCW, na.rm = T))
names(temp0)[ncol(temp0)]<-"PC0_0Total"
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```


###Price Index for the entire commercial fishery ($PI_t$)

We calculate the price index first by comparing by multiplying the previous years $PI_{t-1}$ by that year's price change $PC_{t}$, where the PI of the first year $PI_{t=firstyear} = 1$

$$PI_t = PI_{t-1}*\exp(ln(\frac{P_{t,i}}{P_{t-1,i}})) = PI_{t-1}*\exp(PC_{t})$$

Where

$$PI_{t_{first year}, i} = 1$$

```{r, echo = echoTF(TRUE, code)}
tempPI<-PriceIndex(temp, BaseColName = NameBaseTotal, baseyr)
temp[ncol(temp)+1]<-(tempPI)
names(temp)[ncol(temp)]<-paste0("PI", NameBaseTotal)
```

```{r, echo = echoTF(FALSE, code)}
temp0<-tempPI
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

### Total Implicit Quantity/Output for the entire commercial fishery ($Q_t = Y_t$)
To get quantity estimates for total output using total value of landings divided by price index as follow: $Y=Q=V/I$ 

$$Q_{t}=V_{t}/PI_{t}$$

```{r, echo = echoTF(TRUE, code)}
temp$Q0_0Total<-temp$V0_0Total/temp$PI0_0Total
```

```{r, echo = echoTF(FALSE, code)}
temp0<-temp$Q0_0Total
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

### Total Implicit Quantity/Output Index

$$QI_t = Q_t/Q_{t=baseyr}$$

Where:

 - $QI$ is the sum of Q after these equations
 
```{r, echo = echoTF(TRUE, code)}
    temp$QI0_0Total<-temp$Q0_0Total/temp$Q0_0Total[rownames(temp) %in% baseyr]
```

```{r, echo = echoTF(FALSE, code)}
temp0<-cbind.data.frame("Other..." = rep_len(x = "...", length.out = nrow(temp)), 
                 temp[,(ncol(temp)-4):ncol(temp)])
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

### Sum Total Simple Sum Quantity Output Index

$$QEI_t = QE_t/QE_{t=baseyr}$$

Where:

 - $QE_t$ is the sum of Q before these calculations; the simple sum
 
 - $QEI_t$ is the index of the sum of Q before these equations

```{r, echo = echoTF(TRUE, code)}
temp$QEI0_0Total<-temp$QE0_0Total/temp$QE0_0Total[rownames(temp) %in% baseyr]
```

```{r, echo = echoTF(FALSE, code)}
temp0<-cbind.data.frame("Other..." = rep_len(x = "...", length.out = nrow(temp)), 
                 temp[,(ncol(temp)-4):ncol(temp)])
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

### Solve Output portion of the equation for the Output Changes: 

$$QC_{t} = \sum_{i=1}^n((\frac{R_{it} + R_{it-1}}{2}) * ln(\frac{Q_{it}}{Q_{it-1}}))$$

```{r, echo = echoTF(TRUE, code)}
temp$QC0_0Total<-rowSums(cbind(PriceChange(R0 = temp$R1_0Finfish, P0 = temp$Q1_0Finfish), 
                            PriceChange(R0 = temp$R2_0Shellfish, P0 = temp$Q2_0Shellfish)), 
                       na.rm = T)
```


```{r, echo = echoTF(FALSE, code)}
temp[names(temp) %in% c("Q0_0Total", "QI0_0Total", "QC0_0Total")] %>%
    knitr::kable(row.names = T, booktabs = T)
```

## Other Analysis Warnings Checks

To make sure our analyses worked as inteded, let's see if we can back calculate our numbers.

We want the calcuated V to equal this check:

####1. When back calculated, $V_t$ should equal $PI_t * Q_{t}$?


$$V_t = P_t * Q_t$$

```{r, echo = echoTF(TRUE, code)}
  temp0<-temp[names(temp) %in% c(paste0("Q",NameBaseTotal), 
                                 paste0("PI",NameBaseTotal), 
                                        paste0("V",NameBaseTotal))]
  
  temp0[,(ncol(temp0)+1)]<-temp0[,paste0("Q",NameBaseTotal)]*temp0[,paste0("PI",NameBaseTotal)]
  names(temp0)[ncol(temp0)]<-paste0("V", NameBaseTotal, "_Check")
```
  
```{r, echo = echoTF(FALSE, code)}
temp0%>%
    knitr::kable(row.names = T, booktabs = T)
```

Is there a warning?
  
```{r, echo = echoTF(TRUE, code)}
  if (length(setdiff(as.character(temp0[,paste0("V", NameBaseTotal, "_Check")]), 
                     as.character(temp0[,paste0("V", NameBaseTotal)]))) != 0) {
  warnings.list[length(warnings.list)+1] <- "Warning: When back calculated, V_t did not equal PI_t x Q_t"
  
    a<-warnings.list[length(warnings.list)][[1]]
} else {
    a<-"No warning."
}
```

*`r a `*

####2. When back calculated, $Q_{t}$ should $V_t / PI_{t}$?

$$Q_{t,i} = V_t / PI_{t,i}$$


```{r, echo = echoTF(TRUE, code)}
  temp0<-temp[names(temp) %in% c(paste0("Q",NameBaseTotal), 
                                 paste0("PI",NameBaseTotal), 
                                        paste0("V",NameBaseTotal))]
  temp0[,(ncol(temp0)+1)]<-temp0[,paste0("V",NameBaseTotal)]/temp0[,paste0("PI",NameBaseTotal)]
  names(temp0)[ncol(temp0)]<-paste0("Q", NameBaseTotal, "_Check")
```

```{r, echo = echoTF(FALSE, code)}
temp0%>%
    knitr::kable(row.names = T, booktabs = T)
```

Is there a warning?

```{r, echo = echoTF(TRUE, code)}
  if (length(setdiff(as.character(temp0[,paste0("Q", NameBaseTotal, "_Check")]), 
                     as.character(temp0[,paste0("Q", NameBaseTotal)]))) != 0) {
  warnings.list[length(warnings.list)+1]<-"Warning: When back calculated, Q_t did not equal V_t/PI_t"
    a<-warnings.list[length(warnings.list)][[1]]
} else {
    a<-"No warning."
}
```

*`r a `*

####3. When back calculated, growth rate?

$$ln(Q_t/Q_{t-1}) = \sum( ( \frac{R_{i, t} + R_{i, t-1}}{2})  * ln(\frac{Q_{t,i}}{Q_{t-1,i}}))$$

```{r, echo = echoTF(TRUE, code)}

names0<-c(paste0("Q",NameBaseTotal))
for (i in 1:ii) {
  names0<-c(names0, 
            names(temp)[grep(pattern = paste0("Q", i, "_", NumberOfSpecies), names(temp))],
            names(temp)[grep(pattern = paste0("R", i, "_", NumberOfSpecies), names(temp))])
}

temp0<-temp[,names0]

temp0[,(ncol(temp0)+1)]<-c(NA, ln(temp0[-nrow(temp0),paste0("Q",NameBaseTotal)]/
                              temp0[-1,paste0("Q",NameBaseTotal)]))
names(temp0)[ncol(temp0)]<-"part1"

temp00<-data.frame()
for (i in 1:(ii)) {
  R0<-temp0[,grep(pattern = paste0("R", i), x = names(temp0))]
  Q0<-temp0[,grep(pattern = paste0("Q", i), x = names(temp0))]
  
  for (r in 2:(nrow(temp))){
    temp00[r,i]<-(((R0[r] + R0[r-1])/2) * ln(Q0[r] / Q0[r-1]) )
  }
}

temp0[,(ncol(temp0)+1)]<-rowSums(temp00)
names(temp0)[ncol(temp0)]<-"part2"
```


```{r, echo = echoTF(FALSE, code)}
temp0%>%
    knitr::kable(row.names = T, booktabs = T)
```


Is there a warning?
  
```{r, echo = echoTF(TRUE, code)}

  if (length(setdiff(as.character(temp0[,"part1"]), 
                     as.character(temp0[,"part2"]))) != 0) {
  warnings.list[length(warnings.list)+1]<-"Warning: When back calculated, ln(Q_t/Q_{t-1}) = did not equal sum( ((R_{i, t} - R_{i, t-1})(2))  * ln((Q_{t,i})(Q_{t-1,i}))"
    a<-warnings.list[length(warnings.list)][[1]]
} else {
    a<-"No warning."
}
```


*`r a `*

### View Total Outputs
```{r, echo = echoTF(FALSE, code), warning = FALSE}
# write.csv(x = temp, file = paste0(dir.docu, "Example_Output.csv"))

temp0<-temp[, grepl(pattern = "0Total", x = names(temp))]

temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

### Graph 1: Price Index
In theory, $PI$ should be negative slope after the baseyear and positive after the base year, but because this data was fabricated without thinking of this, we don't see that here. The index value for the base year is = 1, however. 

```{r, echo = echoTF(TRUE, code)}
  title00<- "_PI-Line"
  
  a0<-data.frame(temp[,grepl(
    pattern = paste0("PI[0-9]+_", NumberOfSpecies), 
    x = names(temp))])
  
  a0$Year<-rownames(a0)
  
  a <- gather(a0, Category, val, names(a0)[grepl(pattern = NumberOfSpecies, x = names(a0))], factor_key=TRUE)
  
  a$cat<-as.character(lapply(X = strsplit(x = as.character(a$Category), split = paste0("_", NumberOfSpecies)), function(x) x[2]))
  
  temp0<-a
  
  plotnlines(dat = temp0, title00, place) 
```


### Graph 2: Quantity Index Compare
```{r, echo = echoTF(TRUE, code)}
  title00<- "_QIvQEI-Line"

  temp0<-temp
  temp0$Year<-rownames(temp0)
  
  temp0<-data.frame(temp0[,names(temp0) %in% c("Year", 
                                               paste0("QI", NameBaseTotal), 
                                               paste0("QEI", NameBaseTotal))])
  temp0$Year<-rownames(temp)
  
  temp0<-gather(temp0, cat, val, 
                names(temp0)[1]:names(temp0)[length(names(temp0))-1], 
                factor_key = T)  
  
  plotnlines(dat = temp0,  title00, place) 
  
```

### Graph 3: Quantity Compare
```{r, echo = echoTF(TRUE, code)}
  title00<- "_QvQE-Line"

  temp0<-temp
  temp0$Year<-rownames(temp0)
  
  temp0<-data.frame(temp0[,names(temp0) %in% c("Year", 
                                               paste0("Q", NameBaseTotal), 
                                               paste0("QE", NameBaseTotal))])
  temp0$Year<-rownames(temp)
  
  temp0<-gather(temp0, cat, val, 
                names(temp0)[1]:names(temp0)[length(names(temp0))-1], 
                factor_key = T)  
  
  plotnlines(dat = temp0,  title00, place) 

```


## Do same analysis via a function!

Now that we know the method, we can simplify most of it into a function and do this whole analysis in 4 easy steps: 

 - A. Import and Edit data
 
 - B. Enter base year
 
 - C. Run the function
 
 - D. Obtain the implicit quantity estimates


### Function

`r ifelse(showresults == TRUE, "We use this *ImplicitQuantityOutput* function to calculate the Implicit Quanity Output at Fishery Level:", "")` 

```{r, echo = echoTF(TRUE, code), include = includeTF(TRUE, showresults)}
print(ImplicitQuantityOutput)
```

### A. Import and Edit data
```{r, echo = echoTF(TRUE, code), warning = FALSE}
temp<-read.csv(file = paste0(dir.data, "Tornqvist Index-Calculations_OutputEx.csv"))
rownames(temp)<-temp$year
temp$year<-NULL

temp.q<-temp[,grepl(pattern = "Q", x = names(temp))]
temp.q$QE0_0Total<-rowSums(temp.q, na.rm = T)
temp.q$QE1_0Finfish<-rowSums(temp.q[,grepl(x = names(temp.q), pattern = "Q1") ], na.rm = T)
temp.q$QE2_0Shellfish<-rowSums(temp.q[,grepl(x = names(temp.q), pattern = "Q2") ], na.rm = T)

temp.v<-temp[,grepl(pattern = "V", x = names(temp))]
temp.v$V0_0Total<-rowSums(temp.v, na.rm = T)
temp.v$V1_0Finfish<-rowSums(temp.v[,grepl(x = names(temp.v), pattern = "V1") ], na.rm = T)
temp.v$V2_0Shellfish<-rowSums(temp.v[,grepl(x = names(temp.v), pattern = "V2") ], na.rm = T)

temp<-orgional.data<-cbind.data.frame(temp.q, temp.v)

```

 
### B. Enter base year
```{r, echo = echoTF(TRUE, code), warning = FALSE}
baseyr<-baseyr
```
 
### C. Run the function
```{r, echo = echoTF(TRUE, code), warning = FALSE}
temp00<-ImplicitQuantityOutput(orgional.data, baseyr, pctmiss)
temp<-temp00[[1]]
warnings.list0<-temp00[[2]]
figures.list0<-temp00[[3]]
```

### D. Obtain the implicit quantity estimates
```{r, echo = echoTF(FALSE, code), warning = FALSE}
write.csv(x = temp, file = paste0(dir.docu, "Example_Output.csv"))

temp0<-temp[, grepl(pattern = "0Total", x = names(temp))]

temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

Did all of the analyses work as intended? 

*`r warnings.list0`*

### E. Graph

#### Graph 1: Price Index

For comparison, let's recreate those graphs to make sure we are getting the same output:

```{r, echo = echoTF(TRUE, code)}
figures.list0$`_PI-Line`
```


#### Graph 2: Quantity Index Compare

For comparison, let's recreate those graphs to make sure we are getting the same output:

```{r, echo = echoTF(TRUE, code)}
figures.list0$`_QuantityIndexCompare`
```

#### Graph 3: Quantity Compare

```{r, echo = echoTF(TRUE, code)}
figures.list0$`_QuantityCompare`
```

-------

## Practice with real data (For National Data)

### A. Import and Edit data

Load and subset Data
```{r, echo = echoTF(TRUE, code)}
#Load Data (This data has been edited to include category columns)
landings.data<-read.csv(file = paste0(dir.data, "landings_edited.csv"))
landings.data<-landings.data[landings.data$Year < 2018,] #FUS 2018 hasn't been published yet
landings.data<-landings.data[landings.data$State %in% unique(state.codes$NAME),]
region<-"National"
#We'll categorize by this column I already added to the data
category0 = "category.orig"
```
  
Summary information about the commercial dataset:

`r data.frame(summary(landings.data[,c("Tsn", "Year", "State", "AFS.Name", "Pounds", "Dollars", "category.orig")])) `  
  
Edit/Restructure Data
```{r, echo = echoTF(TRUE, code)}
temp00<-EditCommData(dat = landings.data, category0)
temp<-temp00[[1]]
```

`r data.frame(temp[1:5, 1:5]) ` 

### B. Enter base year
```{r, echo = echoTF(TRUE, code)}
baseyr<-2010
pctmiss = 0.60
```

### C. Run the function
```{r, echo = echoTF(TRUE, code)}
temp00<-ImplicitQuantityOutput(temp, baseyr, pctmiss)
temp<-temp00[[1]]
warnings.list0<-temp00[[2]]
figures.list0<-temp00[[3]]
```

### D. Obtain the implicit quantity estimates
```{r, echo = echoTF(FALSE, code), warning = FALSE}
write.csv(x = temp, file = paste0(dir.docu, "Output_Commercial_", region, ".csv"))

temp0<-temp[, grepl(pattern = "0Total", x = names(temp))]
temp0<-temp0[, !grepl(pattern = "REMOVED_", x = names(temp0))]
names(temp0)<-gsub(pattern = "0", replacement = "", x = names(temp0))
temp0$QE_Total<-NULL
temp0$QEI_Total<-NULL
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

Did all of the analyses work as intended? 

*`r warnings.list0`*

### E. Graph

#### Graph 1: Price Index

For comparison, let's recreate those graphs to make sure we are getting the same output:

```{r, echo = echoTF(TRUE, code)}
figures.list0$`_PI-Line`
```


#### Graph 2: Quantity Index Compare

For comparison, let's recreate those graphs to make sure we are getting the same output:

```{r, echo = echoTF(TRUE, code)}
figures.list0$`_QuantityIndexCompare`
```

#### Graph 3: Quantity Compare

```{r, echo = echoTF(TRUE, code)}
figures.list0$`_QuantityCompare`
```

