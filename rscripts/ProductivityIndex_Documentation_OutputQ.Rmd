---
title: "Productivity Index - Output - By Quantity"
author: "Emily Markowitz (Emily.Markowitz@noaa.gov) and Sun-Ling Wang"
date: "Feb. 27, 2020"
output: 
  pdf_document:
    toc: true
    toc_depth: 4
    number_sections: true
    df_print: kable
---

```{r setup, include=FALSE, echo = FALSE, message  = FALSE}
# knitr::opts_chunk$set(echo = echoTF(TRUE, code))
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=50),tidy=FALSE)
```

#Math Theory: General Total Factor Productivity ($TFP$) Equation

The general form of the $TFP$ can be measured as aggregate output ($Y$) divided by real total inputs ($X$). Rates of TFP growth are constructed using the TÃ¶rnqvist index approach. The TFP growth over two time periods is defined as:

$$ln(TFP_t/TFP_{t-1}) = \sum_{i=1}^n((\frac{R_{t,i} + R_{t-1,i}}{2}) * ln(\frac{Y_{t,i}}{Y_{t-1,i}}))) - \sum_{j=1}^m((\frac{W_{j,t} + W_{j,t-1}}{2}) * ln(\frac{X_{j,t}}{X_{j,t-1}})))$$

Such that:
 
 - Output  = $\sum_{i=1}^n((\frac{R_{it} + R_{it-1}}{2}) * ln(\frac{Y_{it}}{Y_{it-1}}))$

 - Input = $\sum_{j=1}^n((\frac{W_{jt} + W_{jt-1}}{2}) * ln(\frac{X_{jt}}{X_{jt-1}}))$

where: 

 - $Y_i$ are individual outputs. This will later be refered to as $Q_i$ in the following equations. 
 
 - $X_j$ are individual inputs
 
 - $R_i$ are output revenue shares
 
 - $W_j$ are input cost shares
 
 - $t$ and $t-1$ are time subscripts, where 1 is the minimum year in the dataset
 
 - $i$ is category, e.g., Finfish (=1), Shellfish (=2)

 - $s$ is species, e.g., Salmon, Alewife, Surf Clams

-------

#Output Method: From Quantity to Quantity Measures

###Variable Summary

Variables

 - $Q$ are individual quantity outputs in pounds (lbs). 
 
 - $V$ are individual value outputs in dollars ($)

 - $R$ are output revenue shares
 
 - $baseyr$ is the year to base all indicides from
 
 
 Inidicies
 
 - $t$ and $t-1$ are time subscripts, where 1 is the minimum year in the dataset
 
 - $i$ is category, e.g., Finfish (=1), Shellfish (=2)

 - $s$ is species, e.g., Salmon, Alewife, Surf Clams
 

###Data requirements

We need time series data for the value of all species ($V_{t}$; e.g., Total), value of all species in a category (i) ($V_{i=1}$; e.g., Finfish), value of each species in a category (i) ($V_{i=1, s=n}$; e.g., Salmon and Summer Flounder), quanity of all species in a category (i) (in lbs, $Q_{i=1}$; e.g., Finfish and others), and the quantity of each species in a category (i) ($Q_{i=1, s=n}$; e.g., Salmon and Flounder):


#### Edit Data

Here we summate the category and total V because there may be instances where these values may not be the sum of their parts (though they are here). The caluclation Price Index aims to deal with this potiental issue. 

```{r, echo = echoTF(TRUE, code), warning = FALSE}

temp<-read.csv(file = paste0(dir.data, "Tornqvist Index-Calculations_OutputEx.csv"))
rownames(temp)<-temp$year
temp$year<-NULL

temp.q<-temp[,grepl(pattern = "Q", x = names(temp))]
temp.q$QE0_0Total<-rowSums(temp.q, na.rm = T)
temp.q$QE1_0Finfish<-rowSums(temp.q[,grepl(x = names(temp.q), pattern = "Q1") ], na.rm = T)
temp.q$QE2_0Shellfish<-rowSums(temp.q[,grepl(x = names(temp.q), pattern = "Q2") ], na.rm = T)

temp.v<-temp[,grepl(pattern = "V", x = names(temp))]
temp.v$V0_0Total<-rowSums(temp.v, na.rm = T)
temp.v$V1_0Finfish<-rowSums(temp.v[,grepl(x = names(temp.v), pattern = "V1") ], na.rm = T)
temp.v$V2_0Shellfish<-rowSums(temp.v[,grepl(x = names(temp.v), pattern = "V2") ], na.rm = T)

temp<-orgional.data<-cbind.data.frame(temp.q, temp.v)

```


```{r, echo = echoTF(TRUE, code), warning = FALSE}
temp<-orgional.data
temp$Q1_6Flounder<-rnorm(n = nrow(temp), mean = 300, sd = 100)
# temp$Q0_0Total<-temp0$QE0_0Total
```


```{r, echo = echoTF(FALSE, code)}
temp %>%
    knitr::kable(row.names = T, booktabs = T)
```


#### The nameing conventions of the column names. 

For example, in "V1_0Finfish":

 - "V"... refers to the variable represented in the column (here V = "Value")
 
 - ..."1"... refers to the category index (here, = Finfish)
 
  - ..."_"... is simply a seperator in the title
 
 - Since this is the total, ..."0".. refers to the index of the species, which is not relevant since this is the sum of the category, hense = 0
 
 - ..."Finfish" is purely descriptive (here the name of the category), so you can follow along with what is happening!
 
 
Similarly for "Q2_2Clam": 

 - "Q"... refers to the variable represented in the column (here Q = "Quantity")
 
 - ..."2"... refers to the category index (here, = Shellfish)
 
 - ..."_"... is simply a seperator in the title
 
 - ..."2".. refers to the index of the species, such that this organism happens to be the second species of this category. 
 
 - ..."Clams" is purely descriptive (here the name of the species), so you can follow along with what is happening!


###Lets get started


```{r, echo = echoTF(TRUE, code)}
ii<-1 #The category index value
baseyr<-2010
pctmiss<-0.50 #If data are missing by the below percentage, remove data
```

In most of the following examples, we will just focus on the finfish (*i*=1) side of the equation. Here *baseyr* is set to `r baseyr` and the *pctmiss* (The percent of data in a column that we will allow to be missing for analysis; more on that later) is set to `r pctmiss `%. 

`r ifelse(showresults == TRUE, "Here I am just going to do some housekeeping:", "")` 

```{r, echo = echoTF(TRUE, code)}

place <- "Test"

warnings.list<-list() #save issues we encounter in the code 

NumberOfSpecies<-numbers0(x = c(0, strsplit(x = 
                                                strsplit(x = names(temp)[1], 
                                                         split = "_")[[1]][2], 
                                              split = "[a-zA-Z]")[[1]][1]))[1]


NameBaseTotal<-substr(x = sort(names(temp)[grep(x = names(temp), 
                                                    pattern = "0Total")], decreasing = T)[1],
                        start = 2, stop = nchar(sort(names(temp)[grep(x = names(temp), 
                                                                      pattern = "0Total")],
                                                     decreasing = T)[1]))
    
QColumns0<-QColumns<-grep(pattern = paste0("Q", ii,"_"), 
                 x = substr(x = names(temp), 
                            start = 1, 
                            stop = (2+nchar(ii))))
  
QColumns<-QColumns[!(grepl(pattern = paste0("Q", ii,"_", 
                                              numbers0(x = c(0, length(QColumns)-1))[1]), 
                             x = names(temp)[QColumns]))]

VColumns<-grep(pattern = paste0("V", ii,"_"), 
                 x = substr(x = names(temp), 
                            start = 1, 
                            stop = (2+nchar(ii))))
  
NameBasecategory<-substr(start = 2, 
                             stop = nchar(names(temp)[VColumns[(grepl(
                               pattern = paste0("V", ii,"_", NumberOfSpecies), 
                               x = names(temp)[VColumns]))]]), 
                             x = names(temp)[VColumns[(grepl(
                               pattern = paste0("V", ii,"_", NumberOfSpecies), 
                               x = names(temp)[VColumns]))]])  
  
VColumns0<-VColumns<-VColumns[!(grepl(pattern = paste0("V", ii,"_", NumberOfSpecies), 
                             x = names(temp)[VColumns]))]

```


###Remove any V and Q data where V column has less data than the specifed $pctmiss$

```{r, echo = echoTF(TRUE, code)}
intersectcol<-base::intersect(x = substr(x = names(temp[,VColumns]), start = 2, stop = nchar(names(temp[,VColumns]))), 
                      y = substr(x = names(temp[,QColumns]), start = 2, stop = nchar(names(temp[,QColumns]))))
unioncol<-base::union(x = substr(x = names(temp[,VColumns]), start = 2, stop = nchar(names(temp[,VColumns]))), 
                      y = substr(x = names(temp[,QColumns]), start = 2, stop = nchar(names(temp[,QColumns]))))

differentcol<-base::setdiff(unioncol, intersectcol)

if (length(differentcol) != 0) {
  for (i in 1:length(differentcol)) {
    names(temp)[grep(pattern = differentcol[i], x = names(temp))]<-
      paste0("REMOVED_", names(temp)[grep(pattern = differentcol[i], x = names(temp))])
  }
}


for (i in 1:length(VColumns)) {
  
  #if the percent missing is less in V or Q columns for a species than the percentmissingtrheshold, we remove the data before the analysis
  if (sum(is.na(temp[VColumns[i]]))/nrow(temp) > pctmiss | #V
      sum(is.na(temp[QColumns[i]]))/nrow(temp) > pctmiss ) {#Q
    
    names(temp)[VColumns[i]]<-paste0("REMOVED_", names(temp)[VColumns[i]])
    VColumns0<-VColumns0[!(VColumns0 %in% VColumns[i])]
    names(temp)[QColumns[i]]<-paste0("REMOVED_", names(temp)[QColumns[i]])
    QColumns0<-QColumns0[!(QColumns0 %in% QColumns[i])]
  }
}

VColumns<-names(temp)[VColumns0]
QColumns<-names(temp)[QColumns0]

```


```{r, echo = echoTF(FALSE, code)}
temp[,1:6] %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Caluclate Category Sums of $V$ and $Q$

Because we removed some columns for not meeting a perecent missing threshold of `r pctmiss`% and those columns will not be used at all in any part of the further analysis, we need to re-calculate the totals of $V$ and $Q$ for the catagories and the fishery as a whole. 

```{r, echo = echoTF(TRUE, code)}
names(temp)[grep(pattern = NameBasecategory, x = names(temp))]<-
  paste0("REMOVED_", 
         names(temp)[grep(pattern = NameBasecategory, x = names(temp))])

  # Q
  temp.q<-temp[,grepl(pattern = paste0("Q", ii), x = substr(names(temp), start = 1, stop = 2)) ]
  temp.q<-data.frame(temp.q)
  if (ncol(temp.q)>1) {
    temp.q<-rowSums(temp.q, na.rm = T)
  }
  temp[ncol(temp)+1]<-temp.q
  names(temp)[ncol(temp)]<-paste0("QE",NameBasecategory)
  
  # V
  temp.v<-temp[,grepl(pattern = paste0("V", ii), x = substr(names(temp), start = 1, stop = 2)) ]
  temp.v<-data.frame(temp.v)
  if (ncol(temp.v)>1) {
    temp.v<-rowSums(temp.v, na.rm = T)
  }
  temp[ncol(temp)+1]<-temp.v
  names(temp)[ncol(temp)]<-paste0("V",NameBasecategory)
```

```{r, echo = echoTF(FALSE, code)}
temp0<-temp[,grep(pattern = NameBasecategory, x = names(temp))]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```



There may be instances where there are no or too few Q data for that species in a year or ever. The next goal will be to calculate the quantity change, so we need to have a value in there that won't show change. If we left a 0 in the spot, then the price change from 0 to the next year would be huge and misrepresented on the index. To avoid this, we have to deal with four senarios: 

#### 1. If there are instances for a species where there are too few pairs of $Q$ are completely missing from the timeseries or where a percent of $Q$ is missing from the timeseries, we will remove the offending price columns entierly, so they don't influence the downstream price change or price index calculations.  

Let's say here that if `r pctmiss*100 `% of the data is missing in a given $Q_{t,i,s}$, don't use that to calculate that species $Q_{t,i}$

```{r, echo = echoTF(TRUE, code)}
#Find which columns in this table are price Columns

cc<-c() #Empty
for (c in 1:length(QColumns)) {
  
  #If price could never be caluclated at any point in the timeseries (is 0/NaN/NA) for a column (c) 
  #Remove the column from the analysis. 
  #We will not be removing the column from the data, but simply remove it from the varaible "PColumns"
  if (#sum(temp[,PColumns[c]] %in% c(0, NA, NaN)) %in% nrow(temp) |
      sum(temp[,QColumns[c]] %in% c(0, NA, NaN))/nrow(temp) > pctmiss) {
    cc<-c(cc, c)#Collect offending columns
  }
  
}

if (length(cc)>0){
  QColumns<-QColumns[-cc]
}
  
```

```{r, echo = echoTF(FALSE, code)}
temp0<-temp[,QColumns]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```



#### 2. If the first value of $Q_{t,i,s}$ is 0/NA in a timeseries, we (impute) let the next available non-zero/non-NA value of $Q$ in the timeseries inform the past. 

$$where \begin{cases} if: Q_{t,i=1} = 0, then: Q_{t,i=1} = Q_{t,i=1+1...} \\ if: Q_{t,i\neq1} = 0, then: Q_{t,i} = Q_{t-1,i} \end{cases}$$

`r ifelse(showresults == TRUE, "We use this *ReplaceFirst* function:", "")` 
```{r, echo = echoTF(TRUE, code), include = includeTF(TRUE, showresults)}
print(ReplaceFirst)
```

```{r, echo = echoTF(TRUE, code)}
temp<-ReplaceFirst(colnames = QColumns, temp) 
```

```{r, echo = echoTF(FALSE, code)}
temp0<-temp[,QColumns]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

#### 3. If there is a value in the middle of $P_{t,i,s}$'s timeseries that is 0/NA, we (impute) let the most recent past available non-zero/non-NA of $P_{t,i,s}$ in the timeseries inform the future. 

`r ifelse(showresults == TRUE, "We use this *ReplaceMid* function:", "")` 
```{r, echo = echoTF(TRUE, code), include = includeTF(TRUE, showresults)}
print(ReplaceMid) 
```

```{r, echo = echoTF(TRUE, code)}
temp<-ReplaceMid(colnames = QColumns, temp) 
```

```{r, echo = echoTF(FALSE, code)}
temp0<-temp[,QColumns]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Impute values of $V_{t,i,s}$ where P was able to be calculated

To ensure that the price index does not rise or fall to quickly with changes (that are really because of NA values) we fill in the missing instances of $V_{t,i,s}$. 

$$where \begin{cases} if: V_{t,i=1} = 0, then: V_{t,i=1} = V_{t,i=1+1...} \\ if: V_{t,i\neq1} = 0, then: V_{t,i} = V_{t-1,i} \end{cases}$$

#### 1. If the first value of $V_{t,i,s}$ is 0/NA in a timeseries, we let the next available non-zero value of $V_{t,i,s}$ in the timeseries inform the past. 

```{r, echo = echoTF(TRUE, code)}
QColumns<-QColumns[!(grepl(pattern = "REMOVED", x = QColumns))]
VVColumns<-paste0("V", substr(x = QColumns, start = 2, stop = nchar(QColumns)))
temp<-ReplaceFirst(colnames = VVColumns, temp) 
```

```{r, echo = echoTF(FALSE, code)}
temp0<-temp[,VVColumns]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

#### 2. If there is a value in the middle of $V_{t,i,s}$'s timeseries that is 0/NA, we let the most recent past available non-zero of $V_{t,i,s}$ in the timeseries inform the future. 

```{r, echo = echoTF(TRUE, code)}
temp<-ReplaceMid(colnames = VVColumns, temp) 
```

```{r, echo = echoTF(FALSE, code)}
temp0<-temp[,VVColumns]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Value of species $VV_{t,i}$ where Q available

$R_{t,i}$, as defined and discussed in the subsequent step, will need to sum to 1 across all species in a category. Therefore, you will need to sum a new total of $V_{t,i}$ available (called $VV_{t,i}$) for the category using only values for species that were used to calculate $Q_{t,i}$ (called  $V_{t,i,s, available}$). 

$$VV_{t,i} = \sum_{s=1}^{n}(V_{t,i,s, available})$$

where: 

 - $VV_{t,i}$ is the new total of $V_{t,i}$ (called $VV_{t,i}$) for the category using only values for species that were used to calculate $Q_{t,i}$

 - $V_{t,i,s, available}$ are the $V_{t,i,s}$ where $Q_{t,i,s}$ were able to be calculated

```{r, echo = echoTF(TRUE, code)}
temp0<-data.frame(temp[,names(temp) %in% VVColumns], 
                  rowSums(temp[,names(temp) %in% VVColumns], na.rm = T))
names(temp0)[ncol(temp0)]<-paste0("VV",NameBasecategory)
temp0<-data.frame(temp0)
temp[ncol(temp)+1]<-temp0[ncol(temp0)]
```

```{r, echo = echoTF(FALSE, code)}
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Revenue Share for each species ($R_{t,i,s}$; e.g., Salmon and Flounder) 

$$R_{t,i,s} = V_{t,i,s}/VV_{t,i}$$

where: 

 - $R_{t,i,s}$ is the revenue share per individual species (s), category (i), for each year (t)
 
 - $V_{t,i,s}$ is the value ($) per individual species (s), category (i), for each year (t)


Here we divide $V_{t,i,s}$ by $VV_{t,i}$ because $VV_{t,i}$ only includes species used to calculate $V_{t,i,s}$ as per the above price calculations. 

```{r, echo = echoTF(TRUE, code)}
tempR<-data.frame(data = rep_len(x = NA, length.out = nrow(temp)))
for (c in 1:length(QColumns)) {
  
  #for renaming the columns
    NameBase<-substr(start = 2, 
                   stop = nchar(QColumns[c]), 
                   x = QColumns[c]) 
    
  V<-(temp[,names(temp) %in% paste0("VV", NameBasecategory)])  # sum of V where Q was calculated
  V0<-temp[,names(temp) %in% paste0("V", NameBase)] #V of species; to make sure its the same column
  tempR[,c]<-V0/V
  names(tempR)[c]<-paste0("R", NameBase ) #name the column
}

tempR<-data.frame(tempR)
temp<-cbind.data.frame(temp, tempR)
```


```{r, echo = echoTF(FALSE, code)}
tempR %>%
    knitr::kable(row.names = T, booktabs = T)
```

####Analysis Warnings Checks

As an additional check, let's make sure that each row sums to 1. 
```{r, echo = echoTF(FALSE, code)}
rowSums(tempR, na.rm = T) %>%
    knitr::kable(row.names = T, booktabs = T)
```

Is there a warning?

```{r, echo = echoTF(FALSE, code)}
if (sum(rowSums(tempR, na.rm = T)) != nrow(temp)) {
  warnings.list[length(warnings.list)+1]<-paste0("Rows of R_{t,i,s} for ",NameBasecategory," did not sum to 1")
    a<-warnings.list[length(warnings.list)][[1]]
} else {
    a<-"No warning."
}
```

*`r a `*

###Revenue Share-Weighted Qunatity Changes for each species ($QCW_{t,i,s}$; e.g., Salmon and Flounder)

$$QCW_{t,i,s} = \frac{R_{t,i,s} + R_{s,t-1,i}}{2} * ln(\frac{Q_{t,i,s}}{Q_{s,t-1,i}}) = \frac{R_{t,i,s} + R_{s,t-1,i}}{2} * [ln(Q_{t,i,s}) - ln(Q_{s,t-1,i})] $$

Where: 

 - $QCW_{t,i,s}$ = Revenue share-weighted quantity change for a species (s)


Such that: 

 - category's (i) Quantity Change for each species (s) = $\frac{R_{t,i,s} + R_{s,t-1,i}}{2}$

 - category's (i) Revenue Share for each species (s) = $ln(\frac{Q_{t,i,s}}{Q_{s,t-1,i}} = [ln(Q_{t,i,s}) - ln(Q_{s,t-1,i})]$


`r ifelse(showresults == TRUE, "We use this *PriceChange* function. For all intensive purposes, replace $P$ with $Q$:", "")` 

```{r, echo = echoTF(TRUE, code), include = includeTF(TRUE, showresults)}
print(PriceChange)
```

```{r, echo = echoTF(TRUE, code)}
#Find which columns in this table are price and revenue share columns
tempQC<-data.frame(data = rep_len(x = NA, length.out = nrow(temp)))
for (c in 1:length(QColumns)){
  #For nameing columns
    NameBase<-substr(start = 2,
                     stop = nchar(QColumns[c]),
                     x = QColumns[c])
  
  # Calculate
  Q0<-temp[, names(temp) %in% paste0("Q", NameBase)]
  R0<-temp[, names(temp) %in% paste0("R", NameBase)] #to make sure its the same column
  tempQC[,c]<-PriceChange(R0, Q0)
  names(tempQC)[c]<-paste0("QCW", NameBase ) #name the column
}

temp<-cbind.data.frame(temp, tempQC)
```

###Quantity Changes for the category ($QC_{t,i}$; e.g., Finfish)

$$QC_{t,i} = ln(\frac{Q_{t,i}}{Q_{t-1,i}}) = \sum_{s=1}^n(QCW_{t,i,s}) $$ 

Where: 

 - $QC_{t,i}$ = Quantity change for a category (i)

```{r, echo = echoTF(TRUE, code)}
temp[ncol(temp)+1]<-rowSums(tempQC, na.rm = T)
names(temp)[ncol(temp)]<-paste0("QC", NameBasecategory)
```

```{r, echo = echoTF(FALSE, code)}
temp0<-cbind.data.frame(tempQC, rowSums(tempQC, na.rm = T))
names(temp0)[ncol(temp0)]<-paste0("QC", NameBasecategory)
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

###Quantity Index for the each category ($QI_{t,i}$)
    
We calculate the quantity index first by comparing by multiplying the previous years $QI_{t-1}$ by that year's quantity change $QC_{t}$, where the $QI$ of the first year $QI_{t=firstyear,i} = 1$

$$QI_{t,i} = QI_{t-1,i}*\exp(ln(\frac{Q_{t,i,s}}{Q_{t-1,i,s}})) = QI_{t-1,i}*\exp(QC_{t,i})$$

Where

$$QI_{i, t_{first year}} = 1$$
    
Note that the first row of this column is = 1
    
Then, to change the price index into base year dollars, we use the following equation: 
$$QI_{t} = QI_{t}/QI_{t = baseyear}$$
    
```{r, echo = echoTF(TRUE, code)}
tempQI<-PriceIndex(temp, BaseColName = NameBasecategory, baseyr, var = "QC")
temp[ncol(temp)+1]<-(tempQI)
names(temp)[ncol(temp)]<-paste0("QI", NameBasecategory)
```

```{r, echo = echoTF(FALSE, code)}
tempQI %>%
    knitr::kable(row.names = T, booktabs = T)
```


## Redo Analysis for Shellfish

Now lets redo that whole analysis up to this point (via function) for the two species of the shellfish group, as we will need them for the next steps of this analysis. 

`r ifelse(showresults == TRUE, "We use this *ImplicitQuantityOutput* function to calculate the Implicit Quanity Output at Species and category Level:", "")` 

```{r, echo = echoTF(TRUE, code), include = includeTF(TRUE, showresults)}
print(ImplicitQuantityOutput.speciescat.q)
```


```{r, echo = echoTF(TRUE, code)}
ii<-2 #The category index value

tempS<-ImplicitQuantityOutput.speciescat.q(temp, ii, baseyr, maxyr, minyr, 
                         pctmiss = pctmiss, 
                         warnings.list = warnings.list)
temp<-cbind.data.frame(temp, tempS[[1]])
warnings.list<-tempS[[2]]
###Remove duplicate columns
temp<-temp[, !(grepl(pattern = "\\.[0-9]+", x = names(temp)))]
temp<-temp[, !(grepl(pattern = "\\.[0-9]+", x = names(temp)))]
  temp<-temp[, !(grepl(pattern = "\\.[0-9]+", x = names(temp)))]
  temp <- temp[, !duplicated(colnames(temp))]    
```

What does the Shellfish data look like?
```{r, echo = echoTF(FALSE, code)}
temp0<-tempS[[1]][,(ncol(tempS[[1]])-5):ncol(tempS[[1]])]
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```


###Value for all fisheries for species where Q was able to be calculated

$R_{t,i}$, defined and discussed in the subsequent step, will need to sum to 1 across all species in a category. Therefore, you will need to sum a new total of $V_{t,i}$ (called $VV_{t}$) for the category using only values for species that were used to calculate $QI_{t,i}$. 

$$VV_{t} = \sum_{s=1}^{n}(VV_{t,i})$$ 

where: 

 - $VV_{t}$ is the new total of $V_{t,i}$ for the entire fishery using only values for species that were used to calculate $P_{t,i}$

```{r, echo = echoTF(FALSE, code)}
#Total VV
temp0<-data.frame(temp[,grep(pattern = "VV", x = names(temp))], 
                  rowSums(temp[,grep(pattern = "VV", x = names(temp))], na.rm = T))
names(temp0)[ncol(temp0)]<-paste0("VV",NameBaseTotal)
temp0<-data.frame(temp0)
temp[ncol(temp)+1]<-temp0[ncol(temp0)]

```

```{r, echo = echoTF(FALSE, code)}
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

```{r, echo = echoTF(FALSE, code)}
#Total V
names(temp)[names(temp) %in% paste0("V", NameBaseTotal)]<-paste0("REMOVED_V", NameBaseTotal)

temp0<-temp[grep(x = names(temp), 
                            pattern = paste0("V[1-9]+_", NumberOfSpecies))]
temp0<-temp0[,-(grep(x = names(temp0), pattern = c("VV")))]
temp0<-temp0[,-(grep(x = names(temp0), pattern = c("REMOVED_")))]

temp[ncol(temp)+1]<-rowSums(temp0, na.rm = T)
names(temp)[ncol(temp)]<-paste0("V", NameBaseTotal)

```

```{r, echo = echoTF(FALSE, code)}
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```


###Revenue Share for the each category ($R_{t,i}$)

$$R_{t,i} = V_{t,i}/V_{t}$$

where: 

 - $R_{t,i}$ is the revenue share per individual species (s), category (i), for each year (t)
 
 - $V_{t,i}$ is the value ($) per individual species (s), category (i), for each year (t)
 
Here, we don't use $VV_{t}$ beacause we want to expand the proportion to include all of the species caught, regardless if they were used in the quantity calculations. 

```{r, echo = echoTF(TRUE, code)}
category<- c(1,2)
  
for (i in 1:length(category)) {

  CatCol<-names(temp)[grep(pattern = paste0("V", i,"_", NumberOfSpecies), 
                                                  x = substr(x = names(temp), 
                                                             start = 1, 
                                                             stop = nchar(paste0("V", i,"_", NumberOfSpecies))))]
  NameBasecategory<-substr(x = CatCol, start = 2, stop = nchar(CatCol))
    
  temp[,ncol(temp)+1]<-temp[,paste0("V", NameBasecategory)]/temp[,paste0("V", NameBaseTotal)]
  names(temp)[ncol(temp)]<-paste0("R", NameBasecategory)
}

tempR<-temp[,(ncol(temp)-1):ncol(temp)]

```

```{r, echo = echoTF(FALSE, code)}
temp[,c("R1_0Finfish", "R2_0Shellfish", "V1_0Finfish", "V2_0Shellfish", paste0("V", NameBaseTotal))] %>%
    knitr::kable(row.names = T, booktabs = T)
```

####Analysis Warnings Checks

As an additional check, let's make sure that each row sums to 1. 

```{r, echo = echoTF(FALSE, code)}
tempR<-temp[,c("R1_0Finfish", "R2_0Shellfish")]

rowSums(tempR, na.rm = T) %>%
    knitr::kable(row.names = T, booktabs = T)
```

Is there a warning?
```{r, echo = echoTF(FALSE, code)}
if (sum(rowSums(tempR, na.rm = T)) != nrow(temp)) {
  warnings.list[length(warnings.list)+1]<-paste0("Warning: Rows of R_{t,i} for ",NameBaseTotal," did not sum to 1")
    a<-warnings.list[length(warnings.list)][[1]]
} else {
  a<-"No warning."
}
```

*`r a `*



###Revenue Share-Weighted Qunatity Changes for each category ($QCW_{t,i}$; e.g., Finfish and Shellfish)

$$QCW_{t,i} = \frac{R_{t,i,s} + R_{s,t-1,i}}{2} * ln(\frac{QI_{t,i,s}}{QI_{s,t-1,i}}) = \frac{R_{t,i,s} + R_{s,t-1,i}}{2} * [ln(QI_{t,i,s}) - ln(QI_{s,t-1,i})] $$

Where: 

 - $QCW_{t,i}$ = Revenue share-weighted quantity change for each category (i)

Such that: 

 - category's (i) Quantity Change for each category (i) = $\frac{R_{t,i} + R_{t-1,i}}{2}$

 - category's (i) Revenue Share for each category (i) = $ln(\frac{QI_{t,i}}{QI_{t-1,i}} = [ln(QI_{t,i}) - ln(QI_{t-1,i})]$


```{r, echo = echoTF(TRUE, code)}
#Find which columns in this table are price and revenue share columns
tempQC<-data.frame(data = rep_len(x = NA, length.out = nrow(temp)))
for (i in 1:length(category)) {

  CatCol<-names(temp)[grep(pattern = paste0("V", i,"_", NumberOfSpecies), 
                                                  x = substr(x = names(temp), 
                                                             start = 1, 
                                                             stop = nchar(paste0("V", i,"_", NumberOfSpecies))))]
  NameBasecategory<-substr(x = CatCol, start = 2, stop = nchar(CatCol))
    
  # Calculate
  Q0<-temp[, names(temp) %in% paste0("QI", NameBasecategory)]
  R0<-temp[, names(temp) %in% paste0("R", NameBasecategory)] #to make sure its the same column
  tempQC[,i]<-PriceChange(R0, Q0)
  names(tempQC)[i]<-paste0("QCW", NameBasecategory ) #name the column
}

temp<-cbind.data.frame(temp, tempQC)
```

###Quantity Changes for the entire fishery ($QC_{t}$)

$$QC_{t} = ln(\frac{QI_{t,i}}{QI_{t-1,i}}) = \sum_{s=1}^n(QCW_{t,i}) $$ 

Where: 

 - $QC_{t}$ = Quantity change for the entire fishery

```{r, echo = echoTF(TRUE, code)}
temp[ncol(temp)+1]<-rowSums(tempQC, na.rm = T)
names(temp)[ncol(temp)]<-paste0("QC", NameBaseTotal)
```

```{r, echo = echoTF(FALSE, code)}
temp0<-cbind.data.frame(tempQC, rowSums(tempQC, na.rm = T))
names(temp0)[ncol(temp0)]<-paste0("QC", NameBaseTotal)
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```


###Quantity Index for the entier fishery ($QI_{t}$)
    
We calculate the quantity index first by comparing by multiplying the previous years $QI_{t-1}$ by that year's quantity change $QC_{t}$, where the $QI$ of the first year $QI_{t=firstyear,i} = 1$

$$QI_{t} = QI_{t-1}*\exp(ln(\frac{Q_{t,i}}{Q_{t-1,i}})) = QI_{t-1}*\exp(QC_{t})$$

Where

$$QI_{t_{first year}} = 1$$
    
Note that the first row of this column is = 1
    
Then, to change the price index into base year dollars, we use the following equation: 

$$QI_{t} = QI_{t}/QI_{t = baseyear}$$

```{r, echo = echoTF(TRUE, code)}
tempQI<-PriceIndex(temp, BaseColName = NameBaseTotal, baseyr, var = "QC")
temp[ncol(temp)+1]<-(tempQI)
names(temp)[ncol(temp)]<-paste0("QI", NameBaseTotal)
```

```{r, echo = echoTF(FALSE, code)}
tempQI %>%
    knitr::kable(row.names = T, booktabs = T)
```


### Sum Total Simple Sum Quantity Output Index

$$QEI_t = QE_t/QE_{t=baseyr}$$

Where:

 - $QE_t$ is the sum of Q before these calculations; the simple sum
 
 - $QEI_t$ is the index of the sum of Q before these equations

```{r, echo = echoTF(TRUE, code)}
  #remove duplicates
  temp<-temp[, !(grepl(pattern = "\\.[0-9]+", x = names(temp)))]
  temp <- temp[, !duplicated(colnames(temp))]
  temp<-temp[, !(grepl(pattern = "\\.[0-9]+", x = names(temp)))]
  temp <- temp[, !duplicated(colnames(temp))]
  

QE<-names(temp)[grepl(pattern = NameBaseTotal, x = names(temp))]
QE<-QE[substr(x = QE, start = 1, stop = 2) %in% "QE"]
temp[,ncol(temp)+1]<-temp[,QE]/temp[,QE][rownames(temp) %in% baseyr]
names(temp)[ncol(temp)]<-paste0("QEI", NameBaseTotal)
```

```{r, echo = echoTF(FALSE, code)}
temp0<-cbind.data.frame(temp[,paste0("QE", NameBaseTotal)], temp[,paste0("QEI", NameBaseTotal)])
names(temp0)<-c(paste0("QE", NameBaseTotal) ,paste0("QEI", NameBaseTotal))
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```


## Other Analysis Warnings Checks

To make sure our analyses worked as inteded, let's see if we can back calculate our numbers.

We want the calcuated V to equal this check:


####When back calculated, growth rate?

$$ln(Q_t/Q_{t-1}) = \sum( ( \frac{R_{i, t} + R_{i, t-1}}{2})  * ln(\frac{Q_{t,i}}{Q_{t-1,i}}))$$

```{r, echo = echoTF(TRUE, code)}
#Part 1
names0<-c(paste0("QI",NameBaseTotal))
for (i in 1:ii) {
  names0<-c(names0, 
            names(temp)[grep(pattern = paste0("QI", i, "_", NumberOfSpecies), names(temp))],
            names(temp)[grep(pattern = paste0("R", i, "_", NumberOfSpecies), names(temp))])
}

temp0<-temp[,names0]

temp0[,(ncol(temp0)+1)]<-c(NA, ln(temp0[-nrow(temp0),paste0("QI",NameBaseTotal)]/
                              temp0[-1,paste0("QI",NameBaseTotal)]))
names(temp0)[ncol(temp0)]<-"part1"

#Part 2
temp00<-data.frame()
for (i in 1:(ii)) {
  R0<-temp0[,grep(pattern = paste0("R", i), x = names(temp0))]
  Q0<-temp0[,grep(pattern = paste0("QI", i), x = names(temp0))]
  
  for (r in 2:(nrow(temp))){
    temp00[r,i]<-(((R0[r] + R0[r-1])/2) * ln(Q0[r] / Q0[r-1]) )
  }
}

temp0[,(ncol(temp0)+1)]<-rowSums(temp00)
names(temp0)[ncol(temp0)]<-"part2"
```


```{r, echo = echoTF(FALSE, code)}
temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```


Is there a warning?
  
```{r, echo = echoTF(TRUE, code)}

  if (length(setdiff(as.character(temp0[,"part1"]), 
                     as.character(temp0[,"part2"]))) != 0) {
  warnings.list[length(warnings.list)+1]<-"Warning: When back calculated, ln(Q_t/Q_{t-1}) = did not equal sum( ((R_{i, t} - R_{i, t-1})(2))  * ln((Q_{t,i})(Q_{t-1,i}))"
    a<-warnings.list[length(warnings.list)][[1]]
} else {
    a<-"No warning."
}
```


*`r a `*

### View Total Outputs
```{r, echo = echoTF(FALSE, code), warning = FALSE}
# write.csv(x = temp, file = paste0(dir.docu, "Example_Output.csv"))

temp0<-temp[, grepl(pattern = "0Total", x = names(temp))]
temp0<-temp0[, !grepl(pattern = "REMOVED", x = names(temp0))]

temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

### Graph 1: Price Index
In theory, $PI$ should be negative slope after the baseyear and positive after the base year, but because this data was fabricated without thinking of this, we don't see that here. The index value for the base year is = 1, however. 

```{r, echo = echoTF(TRUE, code)}
  title00<- "_QI-Line"
  
  a0<-data.frame(temp[,grepl(
    pattern = paste0("QI[0-9]+_", NumberOfSpecies), 
    x = names(temp))])
  
  a0$Year<-rownames(a0)
  
  a <- gather(a0, Category, val, names(a0)[grepl(pattern = NumberOfSpecies, x = names(a0))], factor_key=TRUE)
  
  a$cat<-as.character(lapply(X = strsplit(x = as.character(a$Category), split = paste0("_", NumberOfSpecies)), function(x) x[2]))
  
  temp0<-a
  
  plotnlines(dat = temp0, title00, place) 
```


### Graph 2: Quantity Index Compare
```{r, echo = echoTF(TRUE, code)}
  title00<- "_QIvQEI-Line"

  temp0<-temp
  temp0$Year<-rownames(temp0)
  
  temp0<-data.frame(temp0[,names(temp0) %in% c("Year", 
                                               paste0("QI", NameBaseTotal), 
                                               paste0("QEI", NameBaseTotal))])
  temp0$Year<-rownames(temp)
  
  temp0<-gather(temp0, cat, val, 
                names(temp0)[1]:names(temp0)[length(names(temp0))-1], 
                factor_key = T)  
  
  plotnlines(dat = temp0,  title00, place) 
  
```

### Graph 3: Quantity Compare
```{r, echo = echoTF(TRUE, code)}
  title00<- "_QvQE-Line"

  temp0<-temp
  temp0$Year<-rownames(temp0)
  
  temp0<-data.frame(temp0[,names(temp0) %in% c("Year", 
                                               paste0("Q", NameBaseTotal), 
                                               paste0("QE", NameBaseTotal))])
  temp0$Year<-rownames(temp)
  
  temp0<-gather(temp0, cat, val, 
                names(temp0)[1]:names(temp0)[length(names(temp0))-1], 
                factor_key = T)  
  
  plotnlines(dat = temp0,  title00, place) 

```


## Do same analysis via a function!

Now that we know the method, we can simplify most of it into a function and do this whole analysis in 4 easy steps: 

 - A. Import and Edit data
 
 - B. Enter base year
 
 - C. Run the function
 
 - D. Obtain the implicit quantity estimates


### Function

`r ifelse(showresults == TRUE, "We use this *ImplicitQuantityOutput* function to calculate the Implicit Quanity Output at Fishery Level:", "")` 

```{r, echo = echoTF(TRUE, code), include = includeTF(TRUE, showresults)}
print(ImplicitQuantityOutput.q)
```

### A. Import and Edit data
```{r, echo = echoTF(TRUE, code), warning = FALSE}
temp<-read.csv(file = paste0(dir.data, "Tornqvist Index-Calculations_OutputEx.csv"))
rownames(temp)<-temp$year
temp$year<-NULL

temp.q<-temp[,grepl(pattern = "Q", x = names(temp))]
temp.q$QE0_0Total<-rowSums(temp.q, na.rm = T)
temp.q$QE1_0Finfish<-rowSums(temp.q[,grepl(x = names(temp.q), pattern = "Q1") ], na.rm = T)
temp.q$QE2_0Shellfish<-rowSums(temp.q[,grepl(x = names(temp.q), pattern = "Q2") ], na.rm = T)

temp.v<-temp[,grepl(pattern = "V", x = names(temp))]
temp.v$V0_0Total<-rowSums(temp.v, na.rm = T)
temp.v$V1_0Finfish<-rowSums(temp.v[,grepl(x = names(temp.v), pattern = "V1") ], na.rm = T)
temp.v$V2_0Shellfish<-rowSums(temp.v[,grepl(x = names(temp.v), pattern = "V2") ], na.rm = T)

temp<-orgional.data<-cbind.data.frame(temp.q, temp.v)

```

 
### B. Enter base year
```{r, echo = echoTF(TRUE, code), warning = FALSE}
baseyr<-baseyr
```
 
### C. Run the function
```{r, echo = echoTF(TRUE, code), warning = FALSE}
temp00<-ImplicitQuantityOutput.q(temp = orgional.data, baseyr, pctmiss)
temp<-temp00[[1]]
warnings.list0<-temp00[[2]]
figures.list0<-temp00[[3]]
```

### D. Obtain the implicit quantity estimates
```{r, echo = echoTF(FALSE, code), warning = FALSE}
write.csv(x = temp, file = paste0(dir.docu, "Example_Output_q.csv"))

temp0<-temp[, grepl(pattern = "0Total", x = names(temp))]

temp0 %>%
    knitr::kable(row.names = T, booktabs = T)
```

Did all of the analyses work as intended? 

*`r warnings.list0`*

### E. Graph

#### Graph 1: Price Index

For comparison, let's recreate those graphs to make sure we are getting the same output:

```{r, echo = echoTF(TRUE, code)}
figures.list0$`_QI-Line`
```


#### Graph 2: Quantity Index Compare

For comparison, let's recreate those graphs to make sure we are getting the same output:

```{r, echo = echoTF(TRUE, code)}
figures.list0$`_QIvQEI-Line`
```

#### Graph 3: Quantity Compare

```{r, echo = echoTF(TRUE, code)}
figures.list0$`_VvVV-Line`
```

